                Welcome to Algorithms


The word "algorithms" was designed to scare young CS students into eating their vegetables. After this course, you'll come to see there is nothing to fear.


Goals of this course

Learn to think algorithmically. Break problems down into easier to solve parts.
Learn about performance optimization. Make your code run faster and more efficiently, even with more data.
Practice solving hard problems. There's no way around it, if you want to be a great developer, you need to solve hard problems.

A word of warning

Don't worry about memorizing this stuff. In particular, don't worry about memorizing the algorithms themselves. My philosophy is that it's mostly a waste of time to memorize anything that's a Google search away.

Instead, focus on understanding how the algorithms work in the moment. You should understand what your code is doing and why - but that doesn't mean you need to memorize the code itself.

Good luck.



                Find Minimum


An "algorithm" is just a set of instructions that can be carried out to solve a problem.

People use algorithms all the time without even realizing it. Practically every function you write in code is an algorithm (well, kinda), even if it's a simple one.

Assignment
In this course, we'll be building pieces of a pretend product: Socialytics - The tool you need to track your growth as an Instagram influencer. We need to show our users the accounts they follow with the lowest follower counts. This will help them know who they follow that isn't popular enough to be worth following anymore.

Implement the "find minimum" algorithm in Python by completing the find_minimum() function:

Set minimum to positive infinity: float("inf").
For each number in the list nums, compare it to minimum. If num is smaller, set minimum to num.
minimum is now set to the smallest number in the list.

Tip
Don't forget to account for edge cases in your function! Check the test code if you're not sure what to expect.


                What is an Algorithm?


In the context of computer science, an algorithm is a finite sequence of well-defined, computer-implementable instructions. In short, an algorithm is:

Defined: there is a specific sequence of steps that performs a task
Unambiguous: there is a "correct" and "incorrect" interpretation of the steps
Implementable: it can be executed using software and hardware

Algorithms are usually written in "pseudocode" (pronounced "sue-dough-code") because an algorithm is a higher-level description of a solution to a problem. An algorithm doesn't care if it's implemented in Python, Go, TypeScript, or (gasp) Java. Pseudocode is just plain English that describes the steps of the algorithm.

Here's some pseudocode for a mystery algorithm:

Start with an original string called S and a new empty string called R.
Loop through S from its last character to its first character, and for each one, add it to the end of R.
Once youâ€™ve processed all the characters, return R.

                Simple Algorithms


If you've heard (usually exaggerated) stories about Leetcode and whiteboarding interviews, you might hear the word "algorithm" and think it's synonymous with "hard problem." That's really not the case, and believing it will only psych you out.

We suffer more often in imagination than in reality

-- Seneca

Algorithms, like anything else, can be understood by breaking them down piece by piece. Take a look at the following algorithm for adding two numbers--it's dead simple:

Start with input variables a and b
Add a and b using the + operator, and assign the result to a new variable, sum
Return the sum variable

Assignment
In Socialytics, we need to calculate the total reach of a group of influencers to estimate how many views a post will get if they all share it.

Complete the sum function. It's a slightly modified version of the algorithm above. Instead of just two numbers, a and b, it accepts a list of numbers and returns the sum of all of them.

Note: The sum of an empty list should be 0.


                Average


We now need a way to show our Instagram influencers the average follower count of the people they follow. This will help them know if they're following people who are more or less popular than them.

Assignment
Complete the average_followers function. It should return the average of the given list of numbers.


                Median


A median is often more useful than an average when the data set contains outliers. For example, if you want to know the typical salary of a software engineer, the median can be a better measure than the average, because the average can be skewed by a few people who make a lot of money.

At Socialytics, we want to show our influencers the median follower count of the people they follow.

Assignment
Complete the median_followers() function to find the median follower count of the given list of numbers.

Order matters - You'll probably want to use the sorted() function to help you out.



                Exponents


I promise we'll get to how this relates to coding, but first we need to review some math stuff.

An exponent indicates how many times a number is to be multiplied by itself.

For example:

53 = 5 * 5 * 5 = 125

Sometimes exponents are also written using the caret symbol (^):

5^3 = 53

Exponent syntax
The ** operator calculates an exponent in Python. (Why not the ^ operator? Blame Fortran.)

square = 2 ** 2
# square = 4

cube = 2 ** 3
# cube = 8

Assignment
In the social media industry, there is a concept called "spread": how much a post spreads due to "reshares" after all of the original author's followers see it. As it turns out, social media posts spread at an exponential rate! We've found that the estimated spread of a post can be calculated with this formula:

estimated_spread = average_audience_followers * ( num_followers ^ 1.2 )

In the formula above, average_audience_followers is an average calculated from each number within the audiences_followers argument - which is a list containing the individual follower counts of the author's followers. For example, if audiences_followers = [2, 3, 2, 19], then:

the author has 4 total followers
each follower has their own 2, 3, 2, and 19 followers, respectively.

Complete the get_estimated_spread function by implementing the formula above. The only input is audiences_followers, which is a list of the follower counts of all the followers the author has. Return the estimated spread. If the audiences_followers list is empty, return 0.


                Exponents Grow


Exponents grow very large very quickly. Let's take a look at an example of them doing that, in code.

Assignment
While the influencers who use our platform are really great at taking selfies, most aren't super great at math. We need to write a tool that predicts an influencer's follower growth over time.

Complete the get_follower_prediction function.

"fitness" influencers: follower count quadruples each month
"cosmetic" influencers: follower count triples each month
All other influencers: follower count doubles each month

For example, if a fitness influencer starts with 10 followers, then after 1 month they should have 40 followers. After 2 months, they would have 160 followers; etc.

Use a geometric sequence formula that's slightly modified for this problem: total = a1 * r^n


                Non-Linear Growth


Exponents are important to understand when it comes to the execution speed of an algorithm. If the number of operations grows quickly as the amount of input data increases, the algorithm will become slower and slower.

Linear	        Quadratic
2 * 2 = 4	    2 ** 2 = 4
3 * 2 = 6	    3 ** 2 = 9
4 * 2 = 8	    4 ** 2 = 16
5 * 2 = 10	    5 ** 2 = 25
6 * 2 = 12	    6 ** 2 = 36
7 * 2 = 14	    7 ** 2 = 49
8 * 2 = 16	    8 ** 2 = 64
9 * 2 = 18	    9 ** 2 = 81

The doubling formula, 2*x, results in linear or straight growth.
The quadratic formula, x^2, keeps growing faster and faster.

What does this have to do with code?
Generally we try to avoid writing code that causes the usage of a resource to grow quadratically (with an exponent).

Sometimes that's a lot of computations (CPU utilization / slowness).
Sometimes that's a lot of memory usage (RAM utilization)
Sometimes that's a large storage requirement (disk space)

A notable exception is in cryptography and security: we want to force attackers to waste resources trying to get at our information.

Notable:
How much larger is 2^64 than 2^32?
2^64 is 2^32 times larger than 2^32


                    Logarithms


A logarithm is the inverse of an exponent.

24 = 16

log216 = 4

"log216" can be read as "log base 2 of 16", and means "the number of times 2 must be multiplied by itself to equal 16".

"log216" might also be written as log2(16)

Some more examples:

Logarithm	Result
log22	        1
log24	        2
log28	        3
log216	        4
log1010	        1
log10100	    2
log101000	    3
log1010000	    4

Python Syntax
There isn't a language-level operator to calculate a logarithm, but we can import the math library and use the math.log() function.

import math

print(f"Logarithm base 2 of 16 is: {math.log(16, 2)}")
# Logarithm base 2 of 16 is: 4.0

Assignment
Let's create an "influencer score". It will be a small number (like less than 100) that will give influencers a metric for comparing their social media success against their peers.

Complete the get_influencer_score function. An influencer score is their engagement percentage multiplied by log base 2 of their follower count.


                Logarithm Quiz

Exponents grow very quickly, and logarithms grow very slowly. A logarithm is the inverse of an exponent.

Generally speaking, it's nice when we can write code that uses log(n) time to run, where n is the amount of data to process. For example, let's say we have a list of 1,000,000 users, and we want to write an algorithm that finds the user with the most followers.

If it takes 1 millisecond to check one user (let's just pretend), a linear algorithm would take 1,000,000 milliseconds, or about 16 minutes and 40 seconds.

A quadratic algorithm (exponent) would take 1,000,000,000,000 milliseconds, or about 31.7 years.

However, a logarithmic algorithm would only take 20 milliseconds! Here's a table to illustrate the difference:


Input Size	Linear (n*2)	Quadratic (n^2)	    Log (log2(n))
10	        20 ms	        100 ms	                3 ms
100	        200 ms	        10,000 ms	            7 ms
1,000	    2,000 ms	    1,000,000 ms	        10 ms
10,000	    20,000 ms	    100,000,000 ms	        14 ms
100,000	    200,000 ms	    10,000,000,000 ms	    17 ms
1,000,000	2,000,000 ms	1,000,000,000,000 ms	20 ms


                Factorials


We're almost done with the math that you'll need for this course! Just one last thing... factorials.

The factorial of a positive integer n, written n!, is the product of all positive integers less than and equal to n.

5! = 5 * 4 * 3 * 2 * 1 = 120

The results of a factorial grow even faster than exponentiation!

n! grows faster than 2^n:

    n!	2^n
2	2	4
3	6	8
4	24	16
5	120	32
6	720	64

Assignment
Influencers need to be able to schedule posts to be published in the future. We've found that the order in which the posts are published drastically affects their performance.

Complete the num_possible_orders function. It takes the number of posts an influencer has in their backlog as input and returns the total number of possible orders in which we could publish the posts.

Tip
Factorials are useful whenever you're trying to count how many ways a collection can be ordered. For example, how many different ways can a deck of cards be arranged?

The first card could be any of the 52 cards.
The second card can be any of the 51 remaining cards.
The third card can be any of the 50 remaining cards, and so on.

That means the total number of possibilities is the 52 options multiplied by 51 options multiplied then by 50 options, and so on.

52 * 51 * 50 ... * 2 * 1

Or in other words, the number of possible combinations for a deck of cards is 52!, or 80,658,175,170,943,878,571,660,636,856,403,766,975,289,505,440,883,277,824,000,000,000,000 (I didn't count the zeros but I think this is correct).