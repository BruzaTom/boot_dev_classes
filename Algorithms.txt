                Welcome to Algorithms


The word "algorithms" was designed to scare young CS students into eating their vegetables. After this course, you'll come to see there is nothing to fear.


Goals of this course

Learn to think algorithmically. Break problems down into easier to solve parts.
Learn about performance optimization. Make your code run faster and more efficiently, even with more data.
Practice solving hard problems. There's no way around it, if you want to be a great developer, you need to solve hard problems.

A word of warning

Don't worry about memorizing this stuff. In particular, don't worry about memorizing the algorithms themselves. My philosophy is that it's mostly a waste of time to memorize anything that's a Google search away.

Instead, focus on understanding how the algorithms work in the moment. You should understand what your code is doing and why - but that doesn't mean you need to memorize the code itself.

Good luck.



                Find Minimum


An "algorithm" is just a set of instructions that can be carried out to solve a problem.

People use algorithms all the time without even realizing it. Practically every function you write in code is an algorithm (well, kinda), even if it's a simple one.

Assignment
In this course, we'll be building pieces of a pretend product: Socialytics - The tool you need to track your growth as an Instagram influencer. We need to show our users the accounts they follow with the lowest follower counts. This will help them know who they follow that isn't popular enough to be worth following anymore.

Implement the "find minimum" algorithm in Python by completing the find_minimum() function:

Set minimum to positive infinity: float("inf").
For each number in the list nums, compare it to minimum. If num is smaller, set minimum to num.
minimum is now set to the smallest number in the list.

Tip
Don't forget to account for edge cases in your function! Check the test code if you're not sure what to expect.


                What is an Algorithm?


In the context of computer science, an algorithm is a finite sequence of well-defined, computer-implementable instructions. In short, an algorithm is:

Defined: there is a specific sequence of steps that performs a task
Unambiguous: there is a "correct" and "incorrect" interpretation of the steps
Implementable: it can be executed using software and hardware

Algorithms are usually written in "pseudocode" (pronounced "sue-dough-code") because an algorithm is a higher-level description of a solution to a problem. An algorithm doesn't care if it's implemented in Python, Go, TypeScript, or (gasp) Java. Pseudocode is just plain English that describes the steps of the algorithm.

Here's some pseudocode for a mystery algorithm:

Start with an original string called S and a new empty string called R.
Loop through S from its last character to its first character, and for each one, add it to the end of R.
Once youâ€™ve processed all the characters, return R.

                Simple Algorithms


If you've heard (usually exaggerated) stories about Leetcode and whiteboarding interviews, you might hear the word "algorithm" and think it's synonymous with "hard problem." That's really not the case, and believing it will only psych you out.

We suffer more often in imagination than in reality

-- Seneca

Algorithms, like anything else, can be understood by breaking them down piece by piece. Take a look at the following algorithm for adding two numbers--it's dead simple:

Start with input variables a and b
Add a and b using the + operator, and assign the result to a new variable, sum
Return the sum variable

Assignment
In Socialytics, we need to calculate the total reach of a group of influencers to estimate how many views a post will get if they all share it.

Complete the sum function. It's a slightly modified version of the algorithm above. Instead of just two numbers, a and b, it accepts a list of numbers and returns the sum of all of them.

Note: The sum of an empty list should be 0.


                Average


We now need a way to show our Instagram influencers the average follower count of the people they follow. This will help them know if they're following people who are more or less popular than them.

Assignment
Complete the average_followers function. It should return the average of the given list of numbers.


                Median


A median is often more useful than an average when the data set contains outliers. For example, if you want to know the typical salary of a software engineer, the median can be a better measure than the average, because the average can be skewed by a few people who make a lot of money.

At Socialytics, we want to show our influencers the median follower count of the people they follow.

Assignment
Complete the median_followers() function to find the median follower count of the given list of numbers.

Order matters - You'll probably want to use the sorted() function to help you out.



                Exponents


I promise we'll get to how this relates to coding, but first we need to review some math stuff.

An exponent indicates how many times a number is to be multiplied by itself.

For example:

53 = 5 * 5 * 5 = 125

Sometimes exponents are also written using the caret symbol (^):

5^3 = 53

Exponent syntax
The ** operator calculates an exponent in Python. (Why not the ^ operator? Blame Fortran.)

square = 2 ** 2
# square = 4

cube = 2 ** 3
# cube = 8

Assignment
In the social media industry, there is a concept called "spread": how much a post spreads due to "reshares" after all of the original author's followers see it. As it turns out, social media posts spread at an exponential rate! We've found that the estimated spread of a post can be calculated with this formula:

estimated_spread = average_audience_followers * ( num_followers ^ 1.2 )

In the formula above, average_audience_followers is an average calculated from each number within the audiences_followers argument - which is a list containing the individual follower counts of the author's followers. For example, if audiences_followers = [2, 3, 2, 19], then:

the author has 4 total followers
each follower has their own 2, 3, 2, and 19 followers, respectively.

Complete the get_estimated_spread function by implementing the formula above. The only input is audiences_followers, which is a list of the follower counts of all the followers the author has. Return the estimated spread. If the audiences_followers list is empty, return 0.


                Exponents Grow


Exponents grow very large very quickly. Let's take a look at an example of them doing that, in code.

Assignment
While the influencers who use our platform are really great at taking selfies, most aren't super great at math. We need to write a tool that predicts an influencer's follower growth over time.

Complete the get_follower_prediction function.

"fitness" influencers: follower count quadruples each month
"cosmetic" influencers: follower count triples each month
All other influencers: follower count doubles each month

For example, if a fitness influencer starts with 10 followers, then after 1 month they should have 40 followers. After 2 months, they would have 160 followers; etc.

Use a geometric sequence formula that's slightly modified for this problem: total = a1 * r^n


                Non-Linear Growth


Exponents are important to understand when it comes to the execution speed of an algorithm. If the number of operations grows quickly as the amount of input data increases, the algorithm will become slower and slower.

Linear	        Quadratic
2 * 2 = 4	    2 ** 2 = 4
3 * 2 = 6	    3 ** 2 = 9
4 * 2 = 8	    4 ** 2 = 16
5 * 2 = 10	    5 ** 2 = 25
6 * 2 = 12	    6 ** 2 = 36
7 * 2 = 14	    7 ** 2 = 49
8 * 2 = 16	    8 ** 2 = 64
9 * 2 = 18	    9 ** 2 = 81

The doubling formula, 2*x, results in linear or straight growth.
The quadratic formula, x^2, keeps growing faster and faster.

What does this have to do with code?
Generally we try to avoid writing code that causes the usage of a resource to grow quadratically (with an exponent).

Sometimes that's a lot of computations (CPU utilization / slowness).
Sometimes that's a lot of memory usage (RAM utilization)
Sometimes that's a large storage requirement (disk space)

A notable exception is in cryptography and security: we want to force attackers to waste resources trying to get at our information.

Notable:
How much larger is 2^64 than 2^32?
2^64 is 2^32 times larger than 2^32


                    Logarithms


A logarithm is the inverse of an exponent.

24 = 16

log216 = 4

"log216" can be read as "log base 2 of 16", and means "the number of times 2 must be multiplied by itself to equal 16".

"log216" might also be written as log2(16)

Some more examples:

Logarithm	Result
log22	        1
log24	        2
log28	        3
log216	        4
log1010	        1
log10100	    2
log101000	    3
log1010000	    4

Python Syntax
There isn't a language-level operator to calculate a logarithm, but we can import the math library and use the math.log() function.

import math

print(f"Logarithm base 2 of 16 is: {math.log(16, 2)}")
# Logarithm base 2 of 16 is: 4.0

Assignment
Let's create an "influencer score". It will be a small number (like less than 100) that will give influencers a metric for comparing their social media success against their peers.

Complete the get_influencer_score function. An influencer score is their engagement percentage multiplied by log base 2 of their follower count.


                Logarithm Quiz

Exponents grow very quickly, and logarithms grow very slowly. A logarithm is the inverse of an exponent.

Generally speaking, it's nice when we can write code that uses log(n) time to run, where n is the amount of data to process. For example, let's say we have a list of 1,000,000 users, and we want to write an algorithm that finds the user with the most followers.

If it takes 1 millisecond to check one user (let's just pretend), a linear algorithm would take 1,000,000 milliseconds, or about 16 minutes and 40 seconds.

A quadratic algorithm (exponent) would take 1,000,000,000,000 milliseconds, or about 31.7 years.

However, a logarithmic algorithm would only take 20 milliseconds! Here's a table to illustrate the difference:


Input Size	Linear (n*2)	Quadratic (n^2)	    Log (log2(n))
10	        20 ms	        100 ms	                3 ms
100	        200 ms	        10,000 ms	            7 ms
1,000	    2,000 ms	    1,000,000 ms	        10 ms
10,000	    20,000 ms	    100,000,000 ms	        14 ms
100,000	    200,000 ms	    10,000,000,000 ms	    17 ms
1,000,000	2,000,000 ms	1,000,000,000,000 ms	20 ms


                Factorials


We're almost done with the math that you'll need for this course! Just one last thing... factorials.

The factorial of a positive integer n, written n!, is the product of all positive integers less than and equal to n.

5! = 5 * 4 * 3 * 2 * 1 = 120

The results of a factorial grow even faster than exponentiation!

n! grows faster than 2^n:

    n!	2^n
2	2	4
3	6	8
4	24	16
5	120	32
6	720	64

Assignment
Influencers need to be able to schedule posts to be published in the future. We've found that the order in which the posts are published drastically affects their performance.

Complete the num_possible_orders function. It takes the number of posts an influencer has in their backlog as input and returns the total number of possible orders in which we could publish the posts.

Tip
Factorials are useful whenever you're trying to count how many ways a collection can be ordered. For example, how many different ways can a deck of cards be arranged?

The first card could be any of the 52 cards.
The second card can be any of the 51 remaining cards.
The third card can be any of the 50 remaining cards, and so on.

That means the total number of possibilities is the 52 options multiplied by 51 options multiplied then by 50 options, and so on.

52 * 51 * 50 ... * 2 * 1

Or in other words, the number of possible combinations for a deck of cards is 52!, or 80,658,175,170,943,878,571,660,636,856,403,766,975,289,505,440,883,277,824,000,000,000,000 (I didn't count the zeros but I think this is correct).

Factorial Quiz
Again, the factorial of a positive integer n, written n!, is the product of all positive integers less than and equal to n.

5! = 5 * 4 * 3 * 2 * 1

Let's visualize how big these things get:

n	n!
2	2
3	6
4	24
5	120
6	720
7	5,040
8	4,0320
9	362,880
10	3,628,800
11	39,916,800
12	479,001,600
13	6,227,020,800
14	87,178,291,200
15	1,307,674,368,000
16	20,922,789,888,000
17	355,687,428,096,000
18	6,402,373,705,728,000
19	121,645,100,408,832,000
20	2,432,902,008,176,640,000


                Exponential Decay


In physics, exponential decay is a process where a quantity decreases over time at a rate proportional to its current value.

We've found that Instagram influencers tend to lose followers similarly. This means that the more followers you have, the faster you lose them.

Assignment
Complete the decayed_followers function.

It calculates the final value of a quantity after a certain time has passed, given its initial value and a rate of decay. Return the remaining followers.

remaining_total = quantity * ( retention_rate ^ time )

The retention_rate is the opposite of fraction_lost_daily. If an influencer lost 0.2 (or 20%) of their followers each day, then the retention rate would be 0.8 (or 80%).

Example
intl_followers = 100

fraction_lost_daily = 0.5

After 0 days: 100 followers

After 1 day: 50 followers

After 2 days: 25 followers

After 3 days: 12.5 followers (rounded down)

Note: This isn't the exact formula shown on Wikipedia, but it's the same idea.


                Logarithmic Scale


In some cases, data can span several orders of magnitude, making it difficult to visualize on a linear scale. A logarithmic scale can help by compressing the data so that it's easier to understand.

For example, at Socialytics we have influencers with follower counts ranging from 1 to 1,000,000,000. If we want to plot the follower count of each influencer on a graph, it would be difficult to see the differences between the smaller follower counts. We can use a logarithmic scale to compress the data so that it's easier to visualize.

Assignment
Write a function log_scale(data, base) that takes a list of positive numbers data, and a logarithmic base, and returns a new list with the logarithm of each number in the original list, using the given base.

You may want to use the math.log() function.

Example:

log_scale([1, 10, 100, 1000], 10)
# Output: [0.0, 1.0, 2.0, 3.0]

log_scale([1, 2, 4, 8], 2)
# Output: [0.0, 1.0, 2.0, 3.0]



                Big O Notation


There are a lot of existing algorithms; some are fast and some are slow. Some use lots of memory. It can be hard to decide which algorithm is the best to solve a particular problem. "Big O" analysis (pronounced "Big Oh", not "Big Zero") is one way to compare the practicality of algorithms.

Big O is a characterization of algorithms according to their worst-case growth rates

We write Big-O notation like this:

O(formula)

Where formula describes how an algorithm's run time or space requirements grow as the input size grows.

see 
https://www.youtube.com/watch?time_continue=649&v=cmahmqABn0g&embeds_referring_euri=https%3A%2F%2Fwww.boot.dev%2F&source_ve_path=MTM5MTE3LDI4NjYzLDI4NjY2

O(1) - constant
O(n) - linear
O(n^2) - squared
O(2^n) - exponential
O(n!) - factorial

The following chart shows the growth rate of several different Big O categories. The size of the input is shown on the x axis and how long the algorithm will take to complete is shown on the y axis.

see(images/big o gaph.jpeg)

As the size of inputs grows, the algorithms become slower to complete (take longer to run). The rate at which they become slower is defined by their Big O category.

For example, O(n) algorithms slow down more slowly than O(n^2) algorithms.

The worst Big-O category?
The algorithms that slow down the fastest in our chart are the factorial and exponential algorithms, or O(n!), and O(2^n).


                O(n) - Order "n"


O(n) is very common - When the number of steps in an algorithm grows at the same rate as its input size, it's classified as O(n)

For example, our find min algorithm from earlier is O(n):

Set min to positive infinity.
For each number in the list, compare it to min. If it is smaller, set min to that number.
min is now set to the smallest number in the list.

The input to the find min algorithm is a list of size n. Because we loop over each item in the input once, we add one step to our algorithm for each item in our list.

As we use find min with larger and larger inputs, the length of time it takes to execute the function grows at a steady linear pace. We can reasonably estimate the time it will take to run, based on a previous measurement. If we find that:

    Input size	     Time to run
find_min(10 items)	    2 ms

Then we can estimate the following:

    Input size	             Time to run
find_min(100 items)	            20 ms
find_min(1000 items)	        200 ms
find_min(10000 items)	        2000 ms

Assignment
At Socialytics we now need to display to our users the people who follow them with the highest engagement count. This will help them know which of their followers they should follow back.

Complete the find_max function. It should take a list of integers and return the largest value in the list.

The "runtime complexity" (aka Big O) of this function should be O(n).


                O(n^2) - Order "n squared"


O(n^2) grows in complexity much more rapidly. That said, for small and medium input sizes, these algorithms can still be very useful.

A common reason an algorithm falls into O(n^2) is by using a nested loop, where the number of iterations of each loop is equal to the number of items in the input:

for person_one in persons:
    for person_two in persons:
        # every combination of people
        # will go on a date... twice!
        go_on_date(person_one, person_two)

Assignment
Socialytics needs search capabilities! For now, we'll build something slow (and frankly awful) so we can see an n^2 algorithm in practice.

Complete the does_name_exist function. It should loop over all of the first/last name combinations in the first_names and last_names lists. If it finds a combination that matches the full_name it should return True. If the full name isn't found, it should return False instead.

                Observe

When you run your completed code, notice how each successive call to does_name_exist takes quite a bit longer. Assuming the length of first_names and last_names is the same, each new name doesn't add n steps to the algorithm it adds n^2 steps.

If does_name_exist(10 names, 10 names) takes just 1 second to complete, then we can estimate:

does_name_exist(100 names, 100 names) = 100 seconds
does_name_exist(1000 names, 1000 names) = 10,000 seconds
does_name_exist(10000 names, 10000 names) = 1,000,000 seconds


                N^2 Quiz


Refer to the following functions, and assume that first_names and last_names are the same length.

def print_names_one(first_names):
    for first_name in first_names:
        print(first_name)

def print_names_two(first_names, last_names):
    for first_name in first_names:
        for last_name in last_names:
            print(first_name, last_name)


                O(nm)


O(nm) is very similar to O(n^2), but instead of a single input that we care about, there are two. If n and m increase at the same rate, then O(nm) is effectively the same as O(n^2). However, if n or m increases faster or slower, then it's useful to track their complexity separately.

Assignment
Socialytics needs a new tool that allows big brands to see how many of an influencer's followers are loyal to their brand. Complete the get_avg_brand_followers function. It takes two inputs:

-all_handles: a 2-dimensional list, or "list of lists" of strings representing instagram user handles on a per-influencer basis.
-brand_name: a string.

get_avg_brand_followers returns the average number of handles that contain the brand_name across all the lists. Each list represents the audience of a single influencer.

Example input/output
Input:

all_handles = [
    ["cosmofan1010", "cosmogirl", "billjane321"],
    ["cosmokiller", "gr8", "cosmojane3"],
    ["iloveboots", "paperthin"]
]
brand_name = "cosmo"

Expected output: 1.33 (handles per influencer, because 4 handles contained "cosmo" and there are 3 lists)

Observe
Regarding Big O, the number of influencers (the number of lists) matters. That's our n. However, the average number of followers of each influencer (the average length of the lists) is just as important. That's our m.