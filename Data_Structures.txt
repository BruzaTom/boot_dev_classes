                
                Introduction to Data Structures


Starting with this chapter, we're going to focus on how we can store and organize data in a way that allows for even better algorithms.

Data structures are just organizational tools that allow for more advanced algorithms. Some examples:

Stacks: Last in, first out.
Queues: First in, first out.
Linked Lists: A chain of nodes, efficient for inserts and deletes.
Binary Trees: A tree where each node has up to two children.
Red Black Trees: A self-balancing binary tree using colors.
Hashmaps: A data structure that maps keys to values.
Tries: A tree used for storing and searching words efficiently.
Graphs: A collection of nodes connected by edges.

Assignment
LockedIn needs some additional features to help keep track of the items inside of it.

Implement the count_marketers function. It should accept a list of strings (job titles) and return the number of "marketers" in the list.

count = count_marketers(['programmer', 'marketer', 'doctor', 'marketer'])
print(count)
# prints "2"

                What Are Data Structures?


A data structure is a data organization, management, and storage format that enables efficient access and modification. More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data.

-- Wikipedia Definition

In other words, a data structure:

Stores data
Organizes data so that it can easily be accessed and modified
Contains algorithmic functions to expose the ability to read and modify the data

you're already familiar with some of Python's built-in, simple data structures:

List: An ordered collection of items
animals = ['cat', 'dog', 'mouse']

Dictionary: Collections of key/value pairs
car = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

                Lists


Okay, we know what lists are, but from a data structures and algorithms perspective, what are they good for? Let's break it down by operation:

Append: Appending an element to the end of a list, e.g. cars.append("ford") is (on average) O(1). We go directly to the end and add the element.

Index: Accessing an element by index, e.g. cars[2] is O(1). We go directly to the index and return the element.

Delete: Removing an element from the middle of a list, e.g. cars.pop(2) is O(n). We have to shift all the elements after the deleted element down one index.

Search: Searching for an element in a list, e.g. cars.index("ford") is O(n). We have to iterate over the list until we find the element.

In other words, lists start to struggle in two primary areas:

When you need to frequently delete elements from the middle of the list
When you need to frequently search for specific elements in the entire list

Assignment
We need to display the last place a user worked on their profile.

Implement the last_work_experience function. It should take a list of our player's work history (strings) and return the last place they worked.

If the list is empty, return None.


                Lists Quiz


Answer the questions based on this code from the last assignment:

def last_work_experience(work_experiences):
    if len(work_experiences) > 0:
        return work_experiences[len(work_experiences) - 1]
    return None

Looking up an item in a list by index is much faster than searching for items using iteration. O(1) vs O(n).

What is the Big-O complexity of the last_work_experience() function, where n is the length of the work_experiences array?

O(1)

Why is index-lookup so much faster than iteration?

the computer can jump straight to the location of an index - an index is like an adress of an item in a list.


                Stacks

                
A stack is a data structure that stores ordered items. It's like a list, but its design is more restrictive. It only allows items to be added or removed from the top of the stack:

It's called a "stack" because it behaves just like a stack of physical items. Imagine a stack of plates: it's easy to take an item off the top of the stack, but you can't really get to the items in the middle or at the bottom without removing the items on top first. You'll often hear a stack referred to as a LIFO (last in, first out) data structure.

Whoever decided to take this simple concept and slap a nasty acronym on it should be forced to program in Prolog for the rest of their days.

Assignment
In this chapter we'll build a stack from scratch! A stack will be useful at LockedIn when we need undo/redo functionality. For example, a user can add other users to their "connections" list, and then undo the last connection they added. Stacks are a great way to implement undo functionality.

For now, we'll just focus on two methods: push and size. Notice that the Stack class already has a constructor and the underlying List that we'll use to store items.

Complete the push method. It should add an item to the top of the stack. The "top" of the stack is the end of the list in our implementation.
Complete the size method. It should return the number of items in the stack.

Stack Speed
You might be wondering, "why would I use a stack instead of a list?". "Isn't this just a list with fewer features?".

And you'd be right! A stack is a list with fewer features, but that's the point. By restricting the ways we can interact with the data, we guarantee that certain operations are blazingly fast. Here are all the operations a typical stack supports, along with their Big O time complexity:

Operation	Big O	Description
push	O(1)	Add an item to the top of the stack
pop	O(1)	Remove and return the top item from the stack
peek	O(1)	Return the top item from the stack without modifying the stack
size	O(1)	Return the number of items in the stack

t's all O(1)! That means no matter how many items are in the stack, these operations will always take the same amount of time. Stacks are really fast and are usually the best choice when the behavior of a stack is all you need.

Which operation is O(1)?
all of them

Where can items be added to and removed from a stack?
top

          Stack Review


All supported operations are O(1) by themselves. However, some tasks, like getting to an item at the bottom of the stack have a higher time complexity because they require multiple pop operations.
Stack operations are limited: no searching, no sorting, no random access
Stacks, like all abstract data types, can store items of any type. What makes it a stack is the behavior of the operations, not the type of data it stores.
Stacks are often used in the real world for:
Function call management
Undo/redo functionality
Expression evaluation
Browser history

What can be stored in a stack?
any things

If you want to get to an item at the bottom of a stack, what is the Big-O to retrieve that item?
O(n) because all other items need to be popped first

            Using a Stack


LockedIn supports a basic scripting language. It allows technically savvy HR managers to write scripts that can automate repetitive tasks on the platform. The language makes use of parentheses to group operations together, and we need to be able to check if the parentheses in a script are balanced.

Balanced Parentheses
Parentheses are balanced when each parenthesis has a corresponding parenthesis, and the pairs of parentheses are properly nested. For example:

()
()()
((()))
(()(()))

Unbalanced Parentheses

(
())
(()()
(()))

Assignment
Complete the is_balanced function.

It takes a string as input and returns True if the parentheses in the string are balanced, and False otherwise. Use an instance of the provided Stack class in stack.py to keep track of the parentheses.

Note: You only need to consider the characters ( and ) for this challenge.


        What Is a Queue?


A queue stores ordered items... again, kind of like a list, but again, like a stack, its design is more restrictive. A queue only allows items to be added to the tail of the queue and removed from the head of the queue.

It's called a "queue" because it behaves like a queue of people waiting in line to order coffee.

The first person to get in line is also the first person to be served (get out of line). So, you'll often hear a queue referred to as a FIFO (first in, first out) data structure.


        Queue Class


Assignment
LockedIn uses a Queue to keep track of the order that recruiters should use to reach out to job seekers.

Implement the following operations on the Queue class:

queue.push(item): Adds an item to the tail of the queue (index 0 of list)
queue.pop(): Removes and returns an item from the head of the queue (last index of list)
queue.peek(): Returns an item from the head of the queue
queue.size(): Returns the number of items in the queue

Note: You'll often hear words used interchangeably in programming. For example, here we're saying push and pop, but enqueue and dequeue are also common words for the same ideas.

term 1	  term 2	  description
Push	    Enqueue	  Adds an item to the tail of the queue
Pop	      Dequeue	  Removes and returns an item from the head of the queue

Tips
The underlying data type we're using is just a List. Don't forget to guard against IndexErrors by returning 'None' if the queue is empty.
The .insert List method may be helpful.


        Queue Speed


So how fast are queue operations? Well, in an optimized queue, they'd be:

Operation	Big O	Description
push	O(1)	Add an item to the back of the queue
pop	  O(1)	Remove and return the front item from the queue
peek	O(1)	Return the front item from the queue without modifying the queue
size	O(1)	Return the number of items in the queue

Just like a stack, all operations are O(1)! No matter how many items are in the queue, these operations will always take the same amount of time. The reason to choose a queue over a stack is all about ordering. Queues should be used when you need to process items in the order they were added.

LIFO (stack) vs FIFO (queue).

A Problem
Our current Queue class has a problem... take a look at the push method:

def push(self, item):
    self.items.insert(0, item)

It's not O(1)! The List's insert method has to shift all the other items in the list down to make room for the new item.

We'll solve this very solvable problem soon...

What is the Big O complexity of the push, pop, peek, and size operations of an optimized queue?
O(1)

If an item could be anywhere in a queue, what is the Big O complexity to retrieve that item?
O(n) because you might have to pop all the items in the queue

Why is our list-based queue's push operation O(n)?
because you have to move all the elements over by one index to make room for the new element


                Matchmaking Queue


In LockedIn, users that are founding companies can join a matchmaking queue to find potential co-founders for their projects. We'll use the Queue class we've built to manage the matchmaking process.

Notice the search_and_remove method on the Queue class (in queue.py). It breaks the rules of a traditional queue data structure but will be useful in solving this real-world problem.

It's okay to violate academic constraints as software engineers as long as we understand the trade-offs involved.

Assignment
Complete the matchmake function that simulates users joining and leaving the matchmaking queue. The function should take a queue instance and a user tuple containing a name and action (either "join" or "leave"):

user = ('Bob', 'join')
user = ('Alice', 'leave')

For each call to matchmake:

If the action is "leave", search the queue for the user and remove them if they are in the queue.

If the action is "join", push the user's name onto the queue.

Lastly, check if the queue has at least 4 users in it. If so, pop the first 2 users from the queue and return the following string:

"{user1} matched {user2}!"

Where user1 is the first user popped and user2 is the second user popped.

If there were less than 4 users in the queue, return the following string: "No match found"


                Linked Lists


Remember how the push method on our Queue is O(n) instead of O(1)?

def push(self, item):
    # everything in self.items has to shift
    # up a position, which takes O(n) time
    self.items.insert(0, item)

Let's fix that.

To build a faster queue, we'll use a Linked List instead of a regular List (array) under the hood. A linked list is where elements are not stored next to each other in memory, instead, each item references the next in a chain.

        Nodes

Our nodes will be represented by a simple class with two fields:

val - The raw string value that the node holds (e.g. 'Carla', 'James', etc)
next - A reference to the next node in the list

Assignment
Let's lock-in and make LockedIn faster!

Complete the Node's constructor. Set its val field to the provided value and its next field to None.
Complete the Node's set_next method. It should set the next field to the provided node.


                Linked List vs. List


A linked list is a collection of ordered items, so it's similar to a "normal" list (also called an "array" or "slice" in other languages).

see images/linked_list_1

Items in a "normal" list are stored next to each other in memory, and to get an item from a normal List we have to use a numbered index:

car = cars[420]

You can think of the "index" as simply an offset from the start. The cars list in this example refers to the start of the list, and 420 is just the 420th item in that section of memory. With a normal list, all the data is stored in the same place in memory and the index is just a way to find the right spot.

In a linked list, there are no indexes! Each node contains two things: the data itself, and a reference to the next node in the list. Iterating over a linked list requires starting at the head node and following the next references until you reach the end.

current_car_node = head_car_node
while current_car_node is not None:
    print(current_car_node.val)
    current_car_node = current_car_node.next

Frankly, linked lists can be annoying to use and incur more overhead, so why use a linked list at all? It's because sometimes linked lists are much faster to make updates to, particularly when inserting or deleting items from the middle.

In a normal list, if you insert an item in the middle, you have to shift all the items after it down one spot, which takes O(n) time:

see images/linked_list_2

In a linked list, once you've traversed to a given node, insertion is (O(1)) because you can simply update two references:

see images/linked_list_3

questons:

You can find an item in a linked list by...
iiterating through all the nodes by following the 'next' reffrences

Linked lists have a faster time complexity than regular lists when it comes to...
inserting/deleting items  in the middle of the list


                Iterating


Even though iterating with linked lists kinda sucks compared to the simplicity of arrays (normal lists), we've got to do it. Although the implementation is more complex and slow, we can still make it easy for users of our class by providing an __iter__ method.

        The yield Keyword

The yield keyword in Python returns a value, kind of like return. However, it's used to turn the function into a generator function.

A generator function creates a new function object. When that function is called, it executes the code in the generator function until it hits a yield statement. At that point, the function pauses and returns the value of the yield statement. The next time the function is called, it picks up right where it left off.

def create_message_generator():
    yield "hi"
    yield "there"
    yield "friend"

gen = create_message_generator()
first = next(gen)
print(first)  # prints: hi
second = next(gen)
print(second)  # prints: there
third = next(gen)
print(third)  # prints: friend

Every time you call create_message_generator(), it creates a new generator instance. To continue from where you left off, you need to assign this generator to a variable (like gen in the example above). This way, when you use next() or loop over the generator, youâ€™re continuing with the same instance rather than starting a new one.

Assignment
The LinkedList class is a wrapper class that uses the Node class we already wrote.

Complete the __init__ method. It should set the head field to None.
No other node points to the linked list's head (first) node, so the LinkedList class itself needs to keep track of it. We'll use the term head and tail like this:

head node -> node -> node -> node -> tail node

The direction of flow above might feel opposite to what you're used to with a Queue, but it's really the same. Above I'm using arrows to show which nodes are pointing to which other nodes. In a future lesson when we implement a Queue using a LinkedList, we'll add elements to the tail and remove elements from the head.

Complete the __iter__ method. It should be a generator function that yields each node in the linked list, from the head to the tail. By overriding the __iter__ method, Python will allow us to use a for loop to iterate over the linked list:

ll = LinkedList()
ll.add("first")
ll.add("second")
ll.add("third")
for val in ll:
    print(val)

Create a reference to the head node (e.g. node = self.head)
Use a while loop to iterate over the linked list until node is None
Yield the current node
Set node to the next node

By overriding the __iter__ method, Python will allow us to use a for loop to iterate over the linked list:

ll = LinkedList()
ll.add("first")
ll.add("second")
ll.add("third")
for val in ll:
    print(val)





                Add to Tail


Time to allow our LinkedList to add new nodes to the end of the list. Kind of like a regular Python List's .append method.


Assignment

Complete the add_to_tail method. It adds a new node to the end of the list and returns nothing.

[see images/add_to_tail.png]

    If there isn't a head node, set the new node as the head and be done.
    Otherwise, keep a reference to the "last" node in the list - start with it set to None.
    Iterate over the linked list (we built this already!)
        Update your "last" node reference to the current node
    Once you've iterated over the entire list, your "last" reference should be the last node in the list (the "tail"). Set the next field of the "last" node to the new node.


              Add to Head


For added flexibility, let's allow users to add items to the front of our linked list as well.
Assignment

Implement the add_to_head method. It should add a new node to the front of the list and return nothing.

    Set the "next" field of the given node to the current head node.
    Update the head reference to the given node.


              Linked List Queue


To use our Linked List as a fast queue (O(1) pushes and pops) we need our add_to_tail function to be O(1). Currently, it iterates over the entire list before appending an item. We can fix this by keeping track of the last item with a new data member: tail.

Note: It's common in algorithms to make this kind of trade-off. By using a little extra memory (keeping track of tail), we can make our operations faster. Sometimes you might need to go the other way, and use more computation time to save memory.

Assignment

LockedIn's queue was working just fine on small datasets, but appending items once the list has 100,000+ items has started to take a toll on our servers. Implement these changes to speed up our Linked List's inserts to O(1):

    add_to_head should set the tail reference to the given node if the list is empty.
    add_to_tail should:
        Set the head and tail to the given node if the list is empty
        Instead of iterating to find the last node, use the tail reference to append the new node
        Update the tail reference to new node
    The constructor should set self.tail to None.


              Remove from Head

We're one method away from having a fully functioning O(1) Queue! We just need a way to remove the first element from the linked list in constant time. When we're finished, our LinkedList will fulfill the basic requirements of a Queue:

    add_to_tail: Constant time insert
    remove_from_head: Constant time pop

Let's rename the LinkedList class to LLQueue and remove the add_to_head functionality because Queues don't allow inserting into the wrong end.

We've also flipped the arrows in the printed representation to reflect the change.

Assignment

Complete the remove_from_head method. It should remove the first node from the list (the head) and return it.

    If the list is empty, just return None.
    The head should now point to the next node in the list (if there is one).
    The tail should be None if the list is now empty
    The old head's Node should no longer point to anything


              Linked List Queue Quiz

Let's recap a few key points about linked lists and queues:

    The problem with our array (normal Python list) implementation of a queue was that it had O(n) push operations.
    The linked list implementation of a queue has O(1) push operations.
    Linked lists are usually a worse choice than standard arrays because:
        They are less performant due to more memory overhead
        They are more complex to work with, debug, and reason about
        They have no random access (indexing to a specific element)
    Doubly linked lists are a better choice than arrays in very specific circumstances because they have O(1) insertions and deletions at both ends of the list.

Question:
A Queue made with a linked list instead of an array...
Answer:
...can have O(1) pushes and pops

Question:
A Queue that uses an array doesn't have O(1) pushes and pops because...
Answer:
When elements are added or removed from the first index of the array, all other elements must be shifted, resulting in O(n) time complexity


              Trees

Trees are a widely used data structure that simulate a hierarchical... well... tree structure. That said, they're typically drawn upside down - the "root" node is at the top, and the "leaves" are at the bottom.

[see images/tree.png]

Trees are kind of like linked lists in the sense that the root node simply holds references to its child nodes, which in turn hold references to their children, but Tree's nodes can have multiple children instead of just one. A generic tree structure has the following rules:

    Each node has a value and may have a list of "children"
    Children can only have a single "parent"


Linked List

node -> node -> node


Tree

Drawn from left to right in this case:

            > node
      > node
            > node
            > node
> node
            > node
            > node
            > node
      > node
            > node

Question:
Multiple nodes in a tree can have the same value
Answer:
sure why not?

Question:
Parent nodes can have ____ child(ren), and children can have ____ parent(s)
Answer:
multiple, one

              Binary Trees

Trees aren't particularly useful data structures unless they're ordered in some way. One of the most common types of ordered tree is a Binary Search Tree or BST. A BST has some additional constraints:

    Instead of an unbounded list of children, each node has at most 2 children
    The left child's value must be less than its parent's value
    The right child's value must be greater than its parent's value
    No two nodes in the BST can have the same value

By ordering the tree like this, we'll be able to add, remove, find, and update nodes much more quickly.

[see videos/what-are-binary-trees.mp4]

Question:
Nodes in a binary tree can have at most ____ child node(s)
Answer:
2

Queston:
Binary search trees, as opposed to generic trees, must be ____
Answer:
ordered left child < parent < right child


              Insert Nodes


The building blocks of a BST are Nodes. In our implementation, we will only use a single class, the BSTNode class. Any BSTNode is technically also a full Binary Search Tree, with itself as the root node (its not aware of any potential parents). All our methods that traverse the tree will do so recursively... have fun! /s

Our LockedIn BSTNode

Throughout this chapter we'll be building a binary search tree to power LockedIn's custom database. LockedIn's management doesn't trust so called "open-source"... so here we are. One of the primary features of databases is the ability to look up records by a single key, and binary search trees are the most common way to implement these fast lookups.

Each node in our BST will represent a LockedIn user. A BSTNode has three properties:

    value: The value of the node, a User object in our case (see user.py). You'll notice that Users have a name and an ID. Comparison operators are already implemented for you on the class, so you should be able to compare User objects with ==, <, and > directly. The ID is the value that we'll use to determine the order of the nodes in the tree.
    left: The left child of the node, another BSTNode or None
    right: The right child of the node, another BSTNode or None

Assignment

Complete the insert method of the BSTNode class. It takes a value as User class as input and adds it to a new node if the value doesn't already exist in the tree.

    If the node doesn't have a value yet, just use the given value and be done
    If the node's value is equal to the given value, just be done, no duplicates allowed
    If the given value is less than the node's value and the node doesn't have a left child, create a new left child node with the given value
    If the given value is less than the node's value and the node does have a left child, recursively call insert on that left child with the given value
    Since we already checked if the given value is equal to or less than the node, the value must be greater than the node. Handle whether or not the node already has a right child

Tip

I'd highly recommend using pencil/paper or some kind of drawing tool to visualize the tree as you go through the assignments in this chapter.


        Insert review


Inserting into a binary search tree (like most of its operations) is very fast. Picture the algorithm that you just wrote in your head: how many comparisons does it take to find the right spot for a new node?

It only requires one comparison for each level of the tree, making it O(log(n))! (At least in a balanced tree, we'll talk about this later).

Order log(n) is very fast - it's practically as good as O(1) in most cases. If our tree has 1,000,000 nodes, we only need to make 20 comparisons to find the right spot for a new node. If our tree is 2x larger (2,000,000 nodes), we only need to make one more comparison per insert, 21 total.

What is the average Big O complexity of the .insert method?
O(log(n))

        
        Min and Max


Some of the simpler BST algorithms are the get_min and get_max methods.
Assignment

Now that we can add users to our BST, our systems team wants us to start implementing search functionality.

Implement the get_min and get_max methods. They should return the minimum and maximum values in the BST respectively.
Assignment

Now that we can add users to our BST, our systems team wants us to start implementing search functionality.

Implement the get_min and get_max methods. They should return the minimum and maximum values in the BST respectively.

Tips

    The get_min function loops through all the left child nodes and returns the value of the last one.
    The get_max function does the same for the right children.


        Delete


We also need a way to remove users from our BST if a user decides to delete their account.
Assignment

Implement the recursive delete method. It takes a value as an input and deletes the node with that value if it exists. Each call returns the new root of the tree (or subtree) after the deletion.

Notice that in the test suite the delete method is called like this:

bst = bst.delete(character)

    Check if the current node is empty (has no value). If it is, return None. This represents an empty tree or a leaf node where deletion has already occurred.
    If the value to delete is less than the current node's value:
        If there's a left child, recursively delete the value from the left subtree and update the left child reference with the result.
        Return the current node.
    If the value to delete is greater than the current node's value:
        If there's a right child, recursively delete the value from the right subtree and update the right child reference with the result.
        Return the current node.
    If the value to delete equals the current node's value, we've found the node to delete:
        If there is no right child, return the left child. This bypasses the current node, effectively deleting it.
        If there is no left child, return the right child, accomplishing the same thing.
        If there are both left and right children, we need to find the new "successor": the smallest node in the right subtree, which is the value next largest after the current node's value.
            Find the smallest node in the right subtree by walking down the current right child's left branches until reaching a node with no left child.
            Replace the current node's value with this successor's value.
            Delete the successor node from the right subtree by recursively calling delete, and update the right child reference with the result.
            Return the current node.

Assignment

Implement the recursive delete method. It takes a value as an input and deletes the node with that value if it exists. Each call returns the new root of the tree (or subtree) after the deletion.

Notice that in the test suite the delete method is called like this:

bst = bst.delete(character)

    Check if the current node is empty (has no value). If it is, return None. This represents an empty tree or a leaf node where deletion has already occurred.
    If the value to delete is less than the current node's value:
        If there's a left child, recursively delete the value from the left subtree and update the left child reference with the result.
        Return the current node.
    If the value to delete is greater than the current node's value:
        If there's a right child, recursively delete the value from the right subtree and update the right child reference with the result.
        Return the current node.
    If the value to delete equals the current node's value, we've found the node to delete:
        If there is no right child, return the left child. This bypasses the current node, effectively deleting it.
        If there is no left child, return the right child, accomplishing the same thing.
        If there are both left and right children, we need to find the new "successor": the smallest node in the right subtree, which is the value next largest after the current node's value.
            Find the smallest node in the right subtree by walking down the current right child's left branches until reaching a node with no left child.
            Replace the current node's value with this successor's value.
            Delete the successor node from the right subtree by recursively calling delete, and update the right child reference with the result.
            Return the current node.


        Deletion Review


The delete method is O(log(n)) because, like most binary tree operations, we don't have to search the entire tree. We only have to search one path from the root to the leaf node we want to delete.

The depth of the tree on average is equal to log base 2 of the number of nodes in the tree. For example:

Nodes 	Depth
1 	    0
2 	    1
4 	    2
8 	    3
16 	    4
32 	    5
64 	    6
128 	  7
256 	  8
512 	  9
1024 	  10
2048 	  11
4096 	  12

We only need to use ~10 steps to delete a node from a tree of ~1000 nodes.

What is the approximate depth of a tree with 16,000 nodes?
14

What is the average Big O of the delete method?
O(log(n))


        Preorder Traversal


A "preorder" traversal is a way to visit all the nodes in a tree. It's called "preorder" because the current node is visited before its children. This tree:

    > 7
        > 6
> 4
    > 2
        > 1

Would be traversed in this order:

[4, 2, 1, 7, 6]

Sometimes it's useful (albeit a bit slow) to iterate over all the nodes in the tree. In the case of LockedIn, we've been asked to build a way to create a backup of our database indexes - this traversal will allow us to save all the data in the tree to a file.

Assignment

Implement the recursive preorder method. It returns a list of the values in the order they are visited, and it takes as an argument the ordering of values we have visited so far.

For example, the first call to preorder on an entire tree would be:

# an empty list is passed in the first call
bst_node.preorder([])

Here are the algorithm's steps:

    Visit the value of the current node by appending its value to the visited array
    Recursively traverse the left subtree
    Recursively traverse the right subtree
    Return the array of visited nodes

# an empty list is passed in the first call
bst_node.preorder([])


Assignment

Implement the recursive preorder method. It returns a list of the values in the order they are visited, and it takes as an argument the ordering of values we have visited so far.

For example, the first call to preorder on an entire tree would be:

# an empty list is passed in the first call
bst_node.preorder([])

Here are the algorithm's steps:

    Visit the value of the current node by appending its value to the visited array
    Recursively traverse the left subtree
    Recursively traverse the right subtree
    Return the array of visited nodes


        Postorder Traversal


A "postorder" traversal also visits all the nodes in a tree. It's called "postorder" because the current node is visited after its children. The following tree:

    > 7
        > 6
> 4
    > 2
        > 1

Would be visited in this order:

[1, 2, 6, 7, 4]


Assignment

Our data team didn't like the way we ordered the users in our BST export (personally I think they just want to kick the work for themselves down the road). Anyhow, we've been asked to change it.

Implement the recursive postorder method. Here are the algorithm's steps:

    Recursively traverse the left subtree
    Recursively traverse the right subtree
    Visit the value of the current node by appending its value to the visited array
    Return array of visited nodes


        Inorder Traversal


An "inorder" traversal is the most intuitive way to visit all the nodes in a tree. It's called "inorder" because the current node is visited between its children. It results in an ordered list of the nodes in the tree. The following tree:

    > 7
        > 6
> 4
    > 2
        > 1

Would be visited in this order:

[1, 2, 4, 6, 7]


Assignment

Turns out, the data team had no idea what they were talking about, and our product lead just wanted an export of our tree in sorted order. He wants to be able to see the users in the order they signed up (and were thus given user IDs).

Implement the recursive inorder method. Here are the algorithm's steps:

    Recursively traverse the left subtree
    Visit the value of the current node by appending its value to the visited array
    Recursively traverse the right subtree
    Return the list of nodes visited so far


        Node Exists


On LockedIn, it's common for one user to navigate directly to another user's profile. We even creepily give the stalked user a notification that someone is looking at their profile.

To make this feature work, we need to be able to quickly check if a user exists in our tree.

Assignment

Complete the exists method.

It should take a value as input and return True if the value exists in the tree, and False if it doesn't. It's a recursive method, as you probably guessed.


        Height


Our DevOps team has been concerned with the hardware required to run the software using our BST. In an effort to diagnose the issue, they've asked us to write a method that returns the height of the tree. For example, this tree:

    > Elrond#3
> Elian#2
    > Astram#1

Has a height of 2 because the longest path from the root node to a leaf node is 2 nodes long.
Assignment

Complete the height method. It returns the height of the tree rooted at the current node.

    If the node's value is None, return 0.
    Recursively calculate the height of the left subtree.
    Recursively calculate the height of the right subtree.
    Use the max() function to return the maximum of the left and right subtree heights plus 1.

Assignment

Complete the height method. It returns the height of the tree rooted at the current node.

    If the node's value is None, return 0.
    Recursively calculate the height of the left subtree.
    Recursively calculate the height of the right subtree.
    Use the max() function to return the maximum of the left and right subtree heights plus 1.


