				GIT notes


			PORCELAIN AND PLUMBING


commands are divided into high-level ("porcelain") commands and low-level ("plumbing") commands.

Some porcelain commands are:

git status
git add
git commit
git push
git pull
git log

Some examples of plumbing commands are:

git apply
git commit-tree
git hash-object

			CONFIG


The very first step of any project is to create a repository. A Git "repository" (or "repo") represents a single project. You'll typically have one repository for each project you work on.

A repo is essentially just a directory that contains a project (other directories and files). The only difference is that it also contains a hidden .git directory. That hidden directory is where Git stores all of its internal tracking and versioning information for the project.

create a new directory called webflyx and cd into it.

mkdir webflyx
cd webflyx

Once inside, create a new Git repository:

git init

You should now have a hidden .git directory in your webflyx directory. This means you've successfully created a new Git repository! List (ls) the contents of the directory to confirm.

HINT
ls -a

			STATUS


A file can be in one of several states in a Git repository. Here are a few important ones:

untracked: Not being tracked by Git
staged: Marked for inclusion in the next commit
committed: Saved to the repository's history

git status

The git status command shows you the current state of your repo. It will tell you which files are untracked, staged, and committed.

			STAGING


The contents.md file has been created, but as we saw, it's untracked. We need to stage it (add it to the "index") with the git add command before committing it later.

Without staging, every file in the repository would be included in every commit, but that's often not what you want.

Here's the command:

git add <path-to-file | pattern>

or 

git add .
(for this directory and all sub directories)

For example:

git add i-use-arch.btw
###
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   contents.md

			COMMIT

After staging a file, we can commit it.

A commit is a snapshot of the repository at a given point in time. It's a way to save the state of the repository, and it's how Git keeps track of changes to the project. A commit comes with a message that describes the changes made in the commit.

Here's how to commit all of your staged files:

git commit -m "your message here"

			HALF OF GIT


You've learned half of Git.
...well, not really. But kind of.

Half of your workflow as a developer will just be 3 simple commands:

git status
git add
git commit
It's most of what you need to work effectively as a solo developer. Another 40% of Git is about collaborating and storing your work on a remote server.

The last 10% is mostly about fixing mistakes, rolling back changes, and other advanced topics. Don't worry, we'll cover those too.

			GIT LOG


A Git repo is a (potentially very long) list of commits, where each commit represents the full state of the repository at a given point in time.

The git log command shows a history of the commits in a repository. This is what makes Git a version control system. You can see:

Who made a commit
When the commit was made
What was changed

			A COMMIT HASH


Each commit has a unique identifier called a "commit hash". This is a long string of characters that uniquely identifies the commit. Here's an example of mine:

5ba786fcc93e8092831c01e71444b9baa2228a4f

For convenience, you can refer to any commit or change within Git by using the first 7 characters of its hash. For mine, that's 5ba786f.

Run the git log command. You should see your commit. Notice that git log (assuming the log is long enough) starts an interactive pager. You can scroll through the log with the arrow keys, and exit by pressing q.

Next, run git log again, but this time use the -n and --no-pager options to limit the maximum number of commits shown, and more importantly, to run it without the interactive pager. E.g.:

git --no-pager log -n 10

			DIFFERENT HASHES


My latest Git commit hash was:

5ba786fcc93e8092831c01e71444b9baa2228a4f

You may have noticed that even though we (you and I) both have the same content in our repositories, we have different commit hashes. While commit hashes are derived from their content changes, there's also some other stuff that affects the end hash. For example:

The commit message
The author's name and email
The date and time
Parent (previous) commit hashes

All this to say that hashes are (almost) always unique, and because they're generated automatically for you, you don't need to worry too much about what goes into them right now.

			NOTE: HASH = SHA


Git uses a cryptographic hash function called SHA-1 to generate commit hashes. We won't go into the details of how SHA-1 works in this course, but it's important to know because you might also hear commit hashes referred to as "SHAs".


			THE PLUMBING


So far we've been using Git in a "porcelain" manner. But to sate our insatiable curiosity, let's take a look at some of the "plumbing".

			IT'S JUST FILES ALL THE WAY DOWN


All the data in a Git repository is stored directly in the (hidden) .git directory. That includes all the commits, branches, tags, and other objects we'll learn about later.

Git is made up of objects that are stored in the .git/objects directory. A commit is just a type of object.

			find your .git objects


-Use git log -n 10 to find your commit hash again.
-Use ls -al to list the contents of the .git/objects directory.
-Look for a directory that suspiciously matches the first two characters of your commit hash.
-Use ls -al to list the contents of that directory and answer the question.


			THE OBJECT FILE


try to cat the contents of the file (which will interpret the contents as text).

cat 411558f4965ade12e3814e1818dcfb1dbc6056

#
 0y  m hm! ␦X_!  I   3 hbe ;H9  3  d␦  4tdcʆ ␦  X2d}@ E  ?   m; +  @    yw 11  !V  t
  Zi8 A = =    (% u y   I I= 

Nope... it's a mess. The contents have been compressed to raw bytes! Let's try again with the xxd command to print the contents of the file in hexadecimal format.

xxd 411558f4965ade12e3814e1818dcfb1dbc6056

#
00000000: 7801 9d8d c90d c230 1000 79bb 8a6d 8068  x......0..y..m.h
00000010: 6dc7 0708 21a0 061a 585f 2112 1b4b 8ef3  m...!...X_!..K..
00000020: 49f5 a406 9e33 d268 6265 9e3b 487f 39f5  I....3.hbe.;H.9.
00000030: 9633 98a0 641a 8bb4 3406 7464 63ca 86b4  .3..d...4.tdc...
00000040: 1a95 f4ae 5832 647d 408b 45d0 d63f b5c1  ....X2d}@.E..?..
00000050: ab6d 3bbd 2bc3 ed40 a695 a6ca 7977 ee31  .m;.+..@....yw.1
00000060: 31cd df21 56be 8374 0ab5 d55a 6938 a341  1..!V..t...Zi8.A
00000070: 1487 3da6 3dff 998b e715 2825 8875 e979  ..=.=.....(%.u.y
00000080: e9eb c049 fc00 4905 3d8a                 ...I..I.=.

			CAT-FILE


Luckily, Git has a built-in plumbing command, cat-file, that allows us to see the contents of a commit without needing to futz around with the object files directly.

git cat-file -p 2d411558f4965ade12e3814e1818dcfb1dbc6056

#
tree 5b21d4f16a4b07a6cde5a3242187f6a5a68b060f
author BruzaTom <thomasagomez77@gmail.com> 1720363323 -0500
committer BruzaTom <thomasagomez77@gmail.com> 1720363323 -0500

A: add contents.md

			TREES AND BLOBS


Now that we understand some of our plumbing equipment, let's get into the pipes. Here are some terms to know:

-tree: git's way of storing a directory
-blob: git's way of storing a file

Here's what I got when I inspected my last commit:

> git cat-file -p 5ba786fcc93e8092831c01e71444b9baa2228a4f

tree 4e507fdc6d9044ccd8a4a3061324c9f711c4667d
author ThePrimeagen <the.primeagen@gmail.com> 1705891256 -0700
committer ThePrimeagen <the.primeagen@gmail.com> 1705891256 -0700

A: add contents.md

Notice that we can see:

The tree object
The author
The committer
The commit message

However, we cannot see the contents of the contents.md file itself! That's because the tree object stores it.

-Use git cat-file -p again, but this time with the hash of the tree object instead of the commit hash.
-You should see a blob object with its own hash.
-Use cat-file again to view the contents of the blob object.
-Run and submit the CLI tests, providing the same blob hash.

			SECOND COMMIT


Reminder of commands:

git log (q to exit, arrow keys to scroll)
git cat-file -p <hash>

Note: log is a porcelain command, while cat-file is a plumbing command. You'll use log much more often when working on coding projects, but cat-file is useful for understanding Git's internals.

Create a second file called titles.md and add the following text:

# Titles

* A River Runs Through It
* Fight Club
* 12 Years a Slave
* The Big Short
* 12 Monkeys

(i used ) cat > titles.md 

Save, stage, and commit the file with any commit message you like as long as it starts with B:. For example, B: add titles.

Use (git cat-file) to inspect the commit you just made. You should notice one extra field in the commit object that wasn't present in the first commit.

parent 2d411558f4965ade12e3814e1818dcfb1dbc6056

			STORING DATA


Git stores an entire snapshot of files on a per-commit level. This was a surprise to me! I always assumed each commit only stored the changes made in that commit.

			OPTIMIZATION


While it's true that Git stores entire snapshots, it does have some performance optimizations so that your .git directory doesn't get too unbearably large.

-Git compresses and packs files to store them more efficiently.
-Git deduplicates files that are the same across different commits. If a file doesn't change between commits, Git will only store it once.

Use git cat-file -p to view the hash of the blob for the titles.md file in your last commit. Save that hash somewhere in your notes.

(blob hash for titles.md)
100644 blob 742ae47550048eceeb91822826d4e6bca55fb897    titles.md

Add a new directory to your project called quotes. Inside, add two files:

TIP

You can stage each file separately:
git add quotes/starwars.md
git add quotes/dune.md

Or you can stage all the changes in your repo at once:
git add .

			GIT CONFIG


Git stores author information so that when you're making a commit it can track who made the change. Here's how you might update your global Git configuration (don't do this yet):

git config --add --global user.name "ThePrimeagen"
git config --add --global user.email "the.primeagen@aol.com"

Let's take the command apart:

*git config: The command to interact with your Git configuration.
*--add: Flag stating you want to add a configuration.
*--global: Flag stating you want this configuration to be stored globally in your ~/.gitconfig. The opposite is "local", which stores the configuration in the current repository only.
*user: The section.
*name: The key within the section.
*"ThePrimeagen": The value you want to set for the key.

You can actually store any old data in your Git configuration. Granted, only certain keys are used by Git, but you can store whatever you want.

Set the following useless key/value pairs in your local Git configuration for the Webflyx repository (omit the --global flag to set them locally):

webflyx.ceo: "ThePrimeagen"
webflyx.cto: "TheLaneagen"
webflyx.valuation: "mid"

Git has a command to view the contents of your config:

git config --list --local

You can also just view the contents of your local config file directly:

cat .git/config

			GET


We've used --list to see all the configuration values, but the --get flag is useful for getting a single value.

git config --get <key>

Keys are in the format <section>.<keyname>. For example:

user.name
webflyx.ceo

Use the --get flag to get the value of the webflyx.valuation key from your local Git configuration.

git config --get webflyx.valuation

			UNSET


The --unset flag is used to remove a configuration value. For example:

git config --unset <key>

Remove the webflyx.cto key from your local Git configuration. Verify that it was removed.

Try using --unset to remove the entire webflyx section.

failed.. needs a key value format

			DUPLICATES


Typically, in a key/value store, like a Python dictionary, you aren't allowed to have duplicate keys. Strangely enough, Git doesn't care.
			
			UNSET ALL


The --unset-all flag is useful if you ever really want to purge all instances of a key from your configuration. Conversely, the --unset flag only works with a single instance of a key.

git config --unset-all example.key

While only the most unhinged of projects operate this way, some projects, including WebFlyx, allow for multiple CEOs. Let's add a few more CEOs to the WebFlyx configuration:

git config --add webflyx.ceo "Warren"
git config --add webflyx.ceo "Carson"
git config --add webflyx.ceo "Sarah"

Take a look at your new cursed configuration:

git config --list --local

Remove all the CEOs from the WebFlyx configuration at once using the --unset-all flag.

git config --unset-all webflyx.ceo

			REMOVE A SECTION


As I pointed out before, the webflyx section is nonsensical because Git doesn't use it for anything. While we can store any key/value pairs we want in our Git configuration, it doesn't mean we should.

The --remove-section flag is used to remove an entire section from your Git configuration. For example:

git config --remove-section section

Remove the entire webflyx section from your local Git config. You might notice that the default "core" section is still there, that's okay.

			LOCATIONS


There are several locations where Git can be configured. From more general to more specific, they are:

-system: /etc/gitconfig, a file that configures Git for all users on the system
-global: ~/.gitconfig, a file that configures Git for all projects of a user
-local: .git/config, a file that configures Git for a specific project
-worktree: .git/config.worktree, a file that configures Git for part of a project

In my experience, 90% of the time you will be using --global to set things like your username and email. The other 9% of the time you will be using --local to set project-specific configurations. The last 1% of the time you might need to futz with system and worktree configurations, but it's extremely rare.

			OVERRIDING


If you set a configuration in a more specific location, it will override the same configuration in a more general location. For example, if you set user.name in the local configuration, it will override the user.name set in the global configuration.

			WHAT IS A BRANCH?

A Git branch allows you to keep track of different changes separately.

For example, let's say you have a big web project and you want to experiment with changing the color scheme. Instead of changing the entire project directly (as of right now, our master branch), you can create a new branch called color_scheme and work on that branch. When you're done, if you like the changes, you can merge the color_scheme branch back into the master branch to keep the changes. If you don't like the changes, you can simply delete the color_scheme branch and go back to the master branch.

			UNDER THE HOOD


A branch is just a named pointer to a specific commit. When you create a branch, you are creating a new pointer to a specific commit. The commit that the branch points to is called the tip of the branch.

			DEFAULT BRANCH


We've been using Git's default master branch. Interestingly, GitHub (a website where you can remotely store Git projects) recently changed its default branch from master to main. As a general rule, I recommend using main as your default branch if you work primarily with GitHub, as we will.

			HOW TO RENAME A BRANCH

git branch -m oldname newname

First, change your global Git configuration to use main as the default branch. Change the init.defaultBranch key to main.

git config --global init.defaultBranch main

Next, check your current branch:

git branch

You should notice that you're still on master! That's because all you did was change the default branch for new repositories. To switch this repo to use main, rename the master branch to main

			NEW BRANCH


You should already be on the main branch: your "default" branch. You can always check with git branch.

			TWO WAYS TO CREATE A BRANCH


git branch my_new_branch

This creates a new branch called my_new_branch. The thing is, I rarely use this command because usually I want to create a branch and switch to it immediately. So I use this command instead:

git switch -c my_new_branch

The switch command allows you to switch branches, and the -c flag tells Git to create a new branch if it doesn't already exist.

When you create a new branch, it uses the current commit you are on as the branch base. For example, if you're on your main branch with 3 commits, A, B, and C, and then you run git switch -c my_new_branch, your new branch will be off C

Create and switch to a new branch called add_classics, it should have the same commits as the main branch.
Run git branch to verify that you are on the new branch.

			SWITCHING BRANCHES


We talked about using git switch to change branches. There's another command that you'll certainly run into because it's been around for a long time and older developers are used to it: git checkout. git switch is a newer command that is meant to be more intuitive and user-friendly. It's recommended to use git switch over git checkout for simply switching branches.

To switch to a branch called prime:

git switch prime

# or, the old way:
git checkout prime

			UPLEVELING OUR ABILITIES


We'll use the add_classics branch to add a commit to the project without affecting the main branch.

We want the following branch structure:

          D    add_classics
         /
A - B - C      main

In other words, the add_classics branch will have all the commits from the main branch, plus a new commit.

Switch to the add_classics branch if you're not already on it.
Create a new file called classics.csv at the root of the project and copy/paste the following content into it:

Stage and commit the new file. The commit message should start with D:, in the same format as the previous exercises.

			LOG FLAGS


As you know, git log shows you the history of commits in your repo. There are a few flags I like to use from time to time to make the output easier to read.

The first is --decorate. It can be one of:

*short (the default)
*full (shows the full ref name)
*no (no decoration)

Run git log --decorate=full. You should see that instead of just using your branch name, it will show the full ref name. A ref is just a pointer to a commit. All branches are refs, but not all refs are branches.

Run git log --decorate=no. You should see that the branch names are no longer shown at all.

The second is --oneline. This flag will show you a more compact view of the log. I use this one all the time, it just makes it so much easier to see what's going on.

git log --oneline

			GIT FILES


KungFu? No, Gitfu.

Remember, Git stores all its information in files in the .git subdirectory at the root of your project, even information about branches. The "heads" (or "tips") of branches are stored in the .git/refs/heads directory. If you cat one of the files in that directory, you should be able to see the commit hash that the branch points to.

Use find and cat to find the commit hash that your main branch points to.

			MERGE


"What's the point of having multiple branches?" you might ask. They're most often used to safely make changes without affecting your (or your team's) primary branch. However, once you're happy with your changes, you'll want to merge them back into the main branch so that they make their way into the final product.

			VISUAL


Let's say you're in a state where you have two branches, each with their own unique commits:

A - B - C    main
   \
    D - E    other_branch

If you merge other_branch into main, Git combines both branches by creating a new commit that has both histories as parents. In the diagram below, F is a merge commit that has C and E as parents. F brings all the changes from D and E back into the main branch.

A - B - C - F    main
   \     /
    D - E        other_branch

First, switch back to main. Next, our contents.md file is eerily empty... update it to contain:

Commit the changes with a message starting with E:. We should now have a commit history that looks like this:

A - B - C - E    main
         \
           D     add_classics

Run git log --oneline --graph --all and you should see a nice ASCII art representation of your commit history.

* e22ce8c (HEAD -> main) E: mod. contents
| * 249b116 (add_classics) D: classics
|/
* 29b71e6 (help) C: add quotes
* d3411f7 B: add titles
* 2d41155 A: add contents.md

			MERGE COMMITS


A merge commit is the result of merging two branches together.

Let's say we start with this:

A - B - C    main
   \
    D - E    vimchadsonly

And we merge vimchadsonly into main by running this while on main:

git merge vimchadsonly

The merge will:

1.Find the "merge base" commit, or "best common ancestor" of the two branches. In this case, "A".

2.Replays the changes from vimchadsonly onto main starting from the best common ancestor.

3.Records the result as a new commit, in our case "F".

4."F" is special because it has two parents, "C" and "E".

After:

A - B - C - F    main
   \     /
    D - E        vimchadsonly

Your current webflyx commit history should look like this:

A - B - C - E    main
         \
           D     add_classics

Let's get the changes from the add_classics branch merged into the main branch. You will be presented with a code editor to change the commit message. Update the message to start with F:. Aside from that, use the default message. E.g. F: Merge branch 'add_classics'.

Save the file, and close the editor. See the tips below if you don't know how to exit the editor.

Finally, still from the main branch run git log --oneline --decorate --graph --parents. This should give you a nice visual representation of the merge commit.

*   e443fa9 e22ce8c 249b116 (HEAD -> main) F: Merge branch 'add_classics'
|\
| * 249b116 29b71e6 (add_classics) D: classics
* | e22ce8c 29b71e6 E: mod. contents
|/
* 29b71e6 d3411f7 (help) C: add quotes
* d3411f7 2d41155 B: add titles
* 2d41155 A: add contents.md

TIPS

Remember, if you mess up a commit message, you can change it with the --amend flag. For example:

git commit --amend -m "F: Merge branch 'add_classics'"

			MERGE LOG


Your output from git log --oneline --decorate --graph --parents (aside from the hashes) should look something like:

*   e443fa9 e22ce8c 249b116 (HEAD -> main) F: Merge branch 'add_classics'
|\
| * 249b116 29b71e6 (add_classics) D: classics
* | e22ce8c 29b71e6 E: mod. contents
|/
* 29b71e6 d3411f7 (help) C: add quotes
* d3411f7 2d41155 B: add titles
* 2d41155 A: add contents.md

Each asterisk * represents a commit in the repository. There are multiple commit hashes on each line because the --parents flag logs the parent hash(es) as well.

1. The first line, with these three hashes: 89629a9 d234104 b8dfd64 is our recent merge commit. The first hash, 89629a9 is the merge commit's hash, and the other two are the parent commits.
2. The next section is a visual representation of the branch structure. It shows the commits on the add_classics branch and the main branch before the merge. Notice that they both share a common parent.
3. The next three lines are just "normal" commits, each pointing to their parent.
4. The last line is the initial commit and therefore has no parent.

			FAST FORWARD MERGE


The simplest type of merge is a fast-forward merge. Let's say we start with this:

      C     delete_vscode
     /
A - B       main

And we run this while on main:

git merge delete_vscode

Because delete_vscode has all the commits that main has, Git automatically does a fast-forward merge. It just moves the pointer of the "base" branch to the tip of the "feature" branch:

            other_branch
A - B - C   main

Notice that with a fast-forward merge, no merge commit is created.

This is a common workflow when working with Git on a team of developers:

Create a branch for a new change
Make the change
Merge the branch back into main (or whatever branch your team dubs the "default" branch)
Remove the branch
Repeat

Because the add_classics branch has been merged into main, we don't need it anymore.

			delete branch


Delete the add_classics branch:

git branch -d add_classics 

1. Create a new branch off main called update_titles. You can use git switch -c.
2. Add a commit to that branch that updates the titles.md file and add "The Curious Case of Benjamin Button" as the final entry in the list of movies. Use G: to prefix the commit message.
3. Run git log --oneline to make sure the commit is there.

			FAST FORWARD COMMIT


Here's a diagram of a fast-forward merge. Before:

      C     other_branch
     /
A - B       main

After a git merge other_branch:

            other_branch
A - B - C   main

No merge commit is created.

Switch back to the main branch, and make sure it doesn't have that last G commit with a quick git log. Next, merge the update_titles branch into main. You should see a fast-forward merge happen automatically because main doesn't have any commits that update_titles doesn't have.

			REBASE


"Rebase vs Merge" is one of the most hotly debated topics in the Git world. A lot of the discussions you'll see online come down to the fact that many developers (yes, even professionals) don't understand the purpose of rebase and use it incorrectly, causing a bunch of Git havoc, and then blame the rebase command.

			VISUALIZING REBASE


Say we have this commit history:

A - B - C    main
   \
    D - E    feature_branch

We're working on feature_branch, and want to bring in the changes our team added to main so we're not working with a stale branch. We could merge main into feature_branch, but that would create an additional merge commit. Rebase avoids a merge commit by replaying the commits from feature_branch on top of main. After a rebase, the history will look like this:

A - B - C         main
         \
          D - E   feature_branch

			NEW BRANCH


We need a new feature branch, but to be able to practice a rebase, we want it to not include some of the recent commits on main.

Use the git switch command to create and switch to a new branch called update_dune, but branch off of the D commit. You can supply the commit hash directly to the git switch command:

git switch -c update_dune COMMITHASH

Replace COMMITHASH with the hash of the D commit, which you can get with a git log command.

Verify with git log --oneline -n 1 that you are on the new branch and that D is the last commit.

			RUN REBASE


To use rebase to bring changes from main onto the current branch (let's call it jdsl), we would run this while on the jdsl branch:

git rebase main

This will do the following:

1. Checkout the latest commit on main
2. Replay one commit at a time from jdsl onto main
3. Update the jdsl branch to point to the last replayed commit
4. The rebase doesn't affect main while jdsl has all of the changes from main

First, let's add two commits to the update_dune branch. Add the following quotes to the quotes/dune.md file's list:

"The spice must flow." (Use a commit message starting with H:)
"Fear is the mind-killer." (Use a commit message starting with I:)

*without rebase

* 298d97a (HEAD -> update_dune) I: add qoute to dune
* 64248c0 H: add quote to dune
* 249b116 D: classics
* 29b71e6 (help) C: add quotes
* d3411f7 B: add titles
* 2d41155 A: add contents.md

Finally, while still on the update_dune branch, rebase your changes onto main. main is the base, and we want update_dune's changes on top of it.

Run git log --oneline. Even though we originally branched off the D commit from main, we should see a nice linear history from A to I.

git log --oneline --graph

* ab8b32a (HEAD -> update_dune) I: add qoute to dune
* 818ca23 H: add quote to dune
* f030fe3 (main) G: add ccobb to titles
*   e443fa9 F: Merge branch 'add_classics'
|\
| * 249b116 D: classics
* | e22ce8c E: mod. contents
|/
* 29b71e6 (help) C: add quotes
* d3411f7 B: add titles
* 2d41155 A: add contents.md

			WHEN TO REBASE


git rebase and git merge are different tools.

An advantage of merge is that it preserves the true history of the project. It shows when branches were merged and where. One disadvantage is that it can create a lot of merge commits, which can make the history harder to read and understand.

A linear history is generally easier to read, understand, and work with. Some teams enforce the usage of one or the other on their main branch, but generally speaking, you'll be able to do whatever you want with your own branches.

			WARNING


You should never rebase a public branch (like main) onto anything else. Other developers have it checked out, and if you change its history, you'll cause a lot of problems for them.

However, with your own branch, you can rebase onto other branches (including a public branch like main) as much as you want.

			UNDOING CHANGES


One of the major benefits of using Git is the ability to undo changes. There are a lot of different ways to do this, but first, we'll start by going back in the commit history without discarding changes.

The new intern at Webflyx tried to add his favorite movie to the titles.md file, but overwrote the entire file by mistake! To simulate that, go ahead and overwrite titles.md with this line: * The Internship

Make sure the file is changed by running git status, then commit the changes. (Use a commit message starting with J:)

			GIT RESET SOFT


The git reset command can be used to undo the last commit(s) or any changes in the index (staged but not committed changes) and the worktree (unstaged and not committed changes).

git reset --soft HEAD~1

The --soft option is useful if you just want to go back to a previous commit, but keep all of your changes. Committed changes will be uncommitted and staged, while uncommitted changes will remain staged or unstaged as before. HEAD~1 refers to the commit 1 before the current commit.

Your current branch, update_dune, should be at commit J with a changed titles.md.

Run git reset --soft HEAD~1 to go back to the I commit while keeping the changed titles.md (staged but not commited).

J should be gone from the commit log. Run and submit the CLI tests from the root of your webflyx directory.

			GIT RESET HARD


In the last lesson, we undid a commit but kept the changes. We don't want to keep the changes to titles.md, here's how to reset those changes.

git reset --hard COMMITHASH

This is useful if you just want to go back to a previous commit and discard all the changes.

Run git status to confirm an unstaged change that modified the titles.md file.

Run git reset --hard to undo the change. Don't move on before you've done this!

Check to make sure the titles.md file is reset:

git status

			DANGER


I want to stress how dangerous this command can be. When you deleted the file, because it was tracked in Git, it was trivially easy to recover. However, if you have some changes that you do want to keep, running git reset --hard will delete them for good.

Always be careful when using git reset --hard. It's a powerful tool, but it's also a dangerous one.

			RESET TO A SPECIFIC COMMIT


If you want to reset back to a specific commit, you can use the git reset --hard command and provide a commit hash. For example:

git reset --hard a1b2c3d

This will reset your working directory and index to the state of that commit, and all the changes made after that commit are lost forever.

Again, be super careful with this. In part 2 of this course, we'll cover more advanced (read: safer) ways to undo changes.

			GIT REMOTE


Often our frenemies (read: coworkers) make code changes that we need to begrudgingly accept into our pristine bug-free repos. /s

This is where the "distributed" in "distributed version control system" comes from. We can have "remotes", which are just external repos with mostly the same Git history as our local repo.

When it comes to Git (the CLI tool), there really isn't a "central" repo. GitHub is just someone else's repo. Only by convention and convenience have we, as developers, started to use GitHub as a "source of truth" for our code.

Let's create a second repo called "webflyx-local" as a sibling directory to our original "webflyx" repo.

Use cd, mkdir, and git init to create the new empty repo.

When you're done, your directory structure should look like this:

webflyx/
  - stuff in the original repo
webflyx-local/
  - stuff we'll put in the new repo

TIP
The new repo's default branch should be main because that's what we set in our init.defaultBranch config.

git config --get init.defaultBranch

			ADDING A REMOTE


In git, another repo is called a "remote." The standard convention is that when you're treating the remote as the "authoritative source of truth" (such as GitHub) you would name it the "origin".

By "authoritative source of truth" we mean that it's the one you and your team treat as the "true" repo. It's the one that contains the most up-to-date version of the accepted code.

			COMMAND SYNTAX


git remote add <name> <uri>

Inside our new repo, add webflyx and give it the name origin. The uri should just be a relative path to the webflyx directory, in our case, ../webflyx.

TIP
if you added the wrong uri you can change it using:

git remote set-url origin <new_remote_url>

			FETCH


Adding a remote to our Git repo does not mean that we automagically have all the contents of the remote. First, we need to fetch the contents.

git fetch

This downloads copies of all the contents of the .git/objects directory (and other book-keeping information) from the remote repository into your current one.

Before fetching the data itself, let's take a look at the new empty repo's .git/objects directory with find.

find .git/objects

			MAKING FETCH HAPPEN


Now, to bring the remote webflyx repo's info into our webflyx-local repo, we have to fetch it.

Run git fetch inside the webflyx-local repo.

Run find .git/objects to see all the new objects that were fetched!

			NOT FETCHED


Just because we fetched all of the metadata from the remote webflyx repo doesn't mean we have all of the files.

To demonstrate this, run git log inside the webflyx-local repo. You should see that you don't have any commits.

			LOG REMOTE


The git log command isn't only useful for your local repo. You can log the commits of a remote repo as well!

git log remote/branch

For example, if you wanted to see the commits of a branch named primeagen from a remote named origin you would run:

git log origin/primeagen

Run git log on the remote webflyx repo's update_dune branch using the --oneline flag. Do it from within the webflyx-local repo. You should see commits "A" through "I".

			MERGE


Just as we merged branches within a single local repo, we can also merge branches between local and remote repos.

			SYNTAX


git merge remote/branch

For example, if you wanted to merge the primeagen branch of the remote origin into your local main branch, you would run this inside the local repo while on the main branch:

git merge origin/primeagen

Merge the remote origin/main into the local repo's main branch. Because we are on an empty branch, we should get a nice clean fast-forward merge.

Make sure it worked with a git log. You should see all the same commits on your local main branch as you do on the remote origin/main branch.

			GITHUB REPOSITORY


GitHub is the most popular website for Git repositories (projects) online. That is, for hosting "remotes" on a central website. GitHub serves several purposes:

1. As a backup of all your code on the cloud in case something happens to your computer
2. As a central place to share your code and collaborate on it with others
3. As a public portfolio for your coding projects

			GIT != GITHUB


It's important to understand that Git and GitHub are not the same! Git is an open-source command line tool for managing code files. GitHub and its primary competitors, GitLab and Bitbucket, are commercial web products that use Git. Their websites give us a way to store our code that's managed by Git.

			CREATE A GITHUB ACCOUNT


If you don't have a GitHub account yet, create one here. You will likely use this account heavily for the rest of your career as a developer, so add a good profile picture and use a sensible username.

Once you've created your account, sync your GitHub account to Boot.dev and submit the check. The check simply ensures that your GitHub account is linked.

			GITHUB REPO 			#connect to github


Just like we created a webflyx-local repo and used webflyx as a remote, GitHub makes it easy to create "remotes" that are hosted on their site.

1. Create a new repository on GitHub called webflyx. Leave it completely blank, and make sure it's public (for now, you can always change it later).

2. Authenticate your local Git configuration with your GitHub account. I recommend installing the GitHub CLI. One quick and easy installation method is to use Webi by simply running:

curl -sS https://webi.sh/gh | sh

then make sure you're authenticated by running this command to login through your browser:

gh auth login

3. Navigate back into your webflyx repo locally, it's going to be our "local" repo, you can forget about or delete webflyx-local if you want.

4. Add a remote to your webflyx repo that points to the webflyx-remote repo you just created. That command should look something like this:

git remote add origin https://github.com/your-username/webflyx.git
be sure to replace your-username with your actual GitHub username!

5. Run git ls-remote to make sure the remote was added correctly.

			GIT PUSH


The git push command pushes (sends) local changes to any "remote" - in our case, GitHub. For example, to push our local main branch's commits to the remote origin's main branch we would run:

git push origin main

You need to be authenticated with the remote to push changes, which you should have done in the last lesson.

			ALTERNATIVE OPTIONS


You can also push a local branch to a remote with a different name:

git push origin <localbranch>:<remotebranch>

It's less common to do this, but nice to know.

You can also delete a remote branch by pushing an empty branch to it:

git push origin :<remotebranch>

Let's push our local main branch to the remote origin repo for safekeeping! Run git push origin main from within the webflyx directory (which should have your GitHub repo configured as a remote).

Navigate to your GitHub repo in your browser and make sure that all your files and commits are there.

			PULL


Fetching is nice, but most of the time we want the actual file changes from a remote repo, not just the metadata.


			COMMAND SYNTAX


git pull [<remote>/<branch>]

The syntax [...] means that the bracketed remote and branch are optional. If you execute git pull without anything specified it will pull your current branch from the remote repo.

Let's use the GitHub UI to commit a change to our remote repo. Then we'll pull that change down to our local repo.

1. Navigate to your GitHub repo in your browser
2. Navigate to the classics.csv file on the main branch
3. In the top right corner, click "Edit this file"
4. Add a new line to the end of the file:

Willow, Ron Howard, 1988

5. Commit the change using the UI, but change the message to: "J: Update classics.csv"
6. On your command line, make sure you're on your main branch
7. merge the changes from the update_dune branch back into main so that main has everything we've done so far (A through I)
8. Run git pull origin main to pull in the most recent "J" commit that you made remotely (If you get a "divergent branches" error, run git config pull.rebase false to make sure git will merge on a pull, then try again.)
9. You should see that it starts a merge commit. Rename the merge commit message to start with K:
10. Make sure everything worked with git log --oneline. You should have commits "A" through "K" locally.

			PULL REQUESTS


On GitHub, a pull request is a way to propose some changes. It's very common to use pull requests if you want to make changes to an open source project, or if you're working on a team.

Pull requests allow team members to see what changes are being proposed and to discuss them before they are merged into the main codebase.

1. Switch to a new branch called add_classics off of main.
2. Add another line to the classics.csv file:

Psycho, Alfred Hitchcock, 1960

3. Stage and commit the change, and prefix the commit message with L:.
4. Push the new branch to GitHub (push it to the remote add_classics branch).
5. Navigate to the GitHub repo in your browser
6. Click on the "Pull requests" tab near the top
7. Click "New pull request".
8. Set the base branch to main and the compare branch to add_classics. We want to merge the add_classics branch into main.
9. Create the pull request, but don't merge it yet!

			MY WORKFLOW


We've covered a lot of Git basics. There's certainly more you can learn, but this will give you a solid foundation to work with as a developer. If you want more, there will be a part 2 of this course released soon where we'll cover more advanced topics.

All that said, I want to leave you with a note on my simple workflow. 90% Of the time, you're only using a handful of git commands to get your coding work done.

			KEEP STUFF ON GITHUB


I keep all my serious projects on GitHub. That way if my computer explodes, I have a backup, and if I'm ever on another computer, I can just clone the repo and get back to work.

			REBASE VS MERGE


I've configured Git to rebase by default on pull, rather than merge so I keep a linear history. If you want to do the same, you can add this to your global Git config:

git config --global pull.rebase true

			MY SOLO WORKFLOW


When I'm working by myself, I usually stick to a single branch, main. I mostly use Git on solo projects to keep a backup remotely and to keep a history of my changes. I only rarely use separate branches.

1. Make changes to files
2. git add . (or git add <files> if I only want to add specific files)
3. git commit -m "a message describing the changes"
4. git push origin main

It really is that simple for most solo work. git log, git reset, and some others are of course useful from time to time, but the above is the core of what I do day-to-day.

			MY TEAM WORKFLOW


When you're working with a team Git gets a bit more involved (and we'll cover more of this in part 2 of this course). Here's what I do:

1. Update my local main branch with git pull origin main
2. Checkout a new branch for the changes I want to make with git switch -c <branchname>
3. Make changes to files
4. git add .
5. git commit -m "a message describing the changes"
6. git push origin <branchname> (I push to the new branch name, not main)
7. Open a pull request on GitHub to merge my changes into main
8. Ask a team member to review my pull request
9. Once approved, click the "Merge" button on GitHub to merge my changes into main
10. Delete my feature branch, and repeat with a new branch for the next set of changes

			GITIGNORE


As you've seen, it's pretty normal to use the following workflow from the top level of your repo:

1. git add .
2. git commit -m "some message here"
3. git push origin main

A problem arises when we want to put files in our project's directory, but we don't want to track them with Git. A .gitignore file solves this. For example, if you work with Python, you probably want to ignore automatically generated files like .pyc and __pycache__. If you are building a server, you probably want to ignore .env files that might hold private keys. If you (I'm sorry) work with JavaScript, you might want to ignore the node_modules directory.

Here's an example .gitignore file, which exists at the root of a repo:

node_modules

This will ignore every path containing node_modules as a "section" (directory name or file name). It ignores:

node_modules/code.js
src/node_modules/code.js
src/node_modules

It does not ignore:

src/node_modules_2/code.js
env/node_modules_3

Create 2 files in your repo:

First, create secure/passwords.txt and create the secure directory if it doesn't exist. Paste the following into the file and save it:

			NESTED GITIGNORE


Your .gitignore file does not necessarily need to be at the root of your project.

It's fairly common to have multiple .gitignore files in different directories throughout a project. A nested .gitignore file only applies to the directory it's in and its subdirectories.

Let's say you have the following setup:

src/
├── assets/
│   ├── .gitignore
|   ├── cover_art.jpg
│   └── onlydevs.png
├── main.py
├── tests.py
├── venv/
│   └── bin/
|       ├── activate
│       └── python
.gitignore

Here's the contents of src/assets/.gitignore:

onlydevs.png
main.py

Here's the contents of the root .gitignore:

venv/bin/activate

			PATTERNS


It would be rough if .gitignore files only accepted exact filepath section names. Luckily, they don't!

Let's go over some of the most common patterns.

			WILDCARDS


The * character matches any number of characters except for a slash (/). For example, to ignore all .txt files, you could use the following pattern:

*.txt

			ROOTED PATTERNS


Patterns starting with a / are anchored to the directory containing the .gitignore file. For example, this would ignore a main.py in the root directory, but not in any subdirectories:

/main.py

			NEGATION


You can negate a pattern by prefixing it with an exclamation mark (!). For example, to ignore all .txt files except for important.txt, you could use the following pattern:

*.txt
!important.txt

			COMMENTS


You can add comments to your .gitignore file by starting a line with a #. For example:

# Ignore all .txt files
*.txt

You can read more about the patterns that are available in the official documentation if you'd like.

Use this .gitignore file to answer the question:

# *.js

*.txt
!names.txt

/src/main.py

content.md

			WHAT TO IGNORE


We've talked about how to ignore files, but the deeper question is what should you ignore? Here are some rules of thumb for coding projects:

1. Ignore things that can be generated (e.g. compiled code, minified files, etc.)
2. Ignore dependencies (e.g. node_modules, venv, packages, etc.)
3. Ignore things that are personal or specific to how you like to work (e.g. editor settings)
4. Ignore things that are sensitive or dangerous (e.g. .env files, passwords, API keys, etc.)

Let's ignore a generated file. We ignore generated files because they can easily be regenerated from the stuff we do track. In this case, we're going to use Pandoc to generate HTML from a Markdown file. We'll ignore the HTML file, but commit the Markdown file.

First, install Pandoc, a command line tool for converting between different document formats. If you're on Mac:

sudo apt install pandoc

Create a new file at the root of the repository called advert.md with the following content:

# WebFlyx: The Future of Content

You thought you knew what the web was capable of. You were *wrong*. WebFlyx is taking the world of online entertainment to an entirely new level. Grab a copy of it at your local electronics store today!

**Available on Floppy Disk!**

*While supplies last.*

Run the following command to generate an HTML document (webpage) from the Markdown file:

pandoc advert.md -o advert.html

For fun, open the HTML in your browser to see a nicely formatted version of the Markdown file.

# WSL
explorer.exe advert.html

Finally, add the advert.html file to the .gitignore file and commit your changes with a message starting with N:.

			GIT CLONE


Let's clone down the GitHub repo onto your machine and open it in your editor.

By creating a project on GitHub first and cloning it down, the remote connection between your local project and GitHub will be configured automatically. If you start your project on your local machine and push it up later, there are a few more steps involved. That's why I prefer git clone to git init + git remote add origin.

Clone your bookbot repo by running this command inside your USERNAME directory and replacing USERNAME with your GitHub username:

git clone https://github.com/USERNAME/bookbot

If all goes well, you'll now have a new bookbot directory in your current working directory. You can check by running the "list" command:


			
