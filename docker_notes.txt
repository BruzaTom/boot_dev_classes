                                

                                Docker

Docker is the big name in "containerization". The big idea behind Docker and other container technologies is that they allow us to package our programs with an environment and ship the whole thing. Most real world programs don't work in isolation, they need:

    Files from disk
    Environment variables
    Installed dependencies
    Specific permissions

Docker images and containers have become a standard for deploying applications. In this course, you'll learn all about Docker and containerization.
Boot.dev CLI

Throughout this course, you'll be using the Boot.dev CLI to run our tests (which are just CLI commands) against your local environment. Install it now if you don't already have it. All the instructions and troubleshooting info are on the GitHub page.

Make sure the Boot.dev CLI install worked:

bootdev --version

If you're stuck, reach out in the help forums of the Discord.

Once the bootdev command is working, log in and follow the instructions:

bootdev login

Boot.dev CLI

Throughout this course, you'll be using the Boot.dev CLI to run our tests (which are just CLI commands) against your local environment. Install it now if you don't already have it. All the instructions and troubleshooting info are on the GitHub page.

Make sure the Boot.dev CLI install worked:

bootdev --version

If you're stuck, reach out in the help forums of the Discord.

Once the bootdev command is working, log in and follow the instructions:

bootdev login


Run vs. Submit

Lessons have a series of "commands" that run on your local machine, and a series of tests it will check against the results of the command. There are two ways to run these commands: run and submit:

    bootdev run <id>: This will run the commands and show you the results. It's to be used for debugging, but it won't tell you whether or not you've passed the tests explicitly.
    bootdev run <id> -s: This will run the commands and give you pass/fail feedback. It will also mark the lesson as complete on the website. If you get it wrong however, you'll potentially lose your sharpshooter spree, so be sure to use run first!

You can copy the run/submit commands with the id ready-to-go from the test panel.
Assignment

Once you have the CLI installed and you're logged in, copy and paste the run command from the right into your terminal and execute it. If it's doing what you'd expect (printing it works on my machine), then run the submit command.
Assignment

Once you have the CLI installed and you're logged in, copy and paste the run command from the right into your terminal and execute it. If it's doing what you'd expect (printing it works on my machine), then run the submit command.


        Install Docker


There are a couple of moving parts to keep in mind when it comes to using Docker on your local machine:

    The "Docker server" or "Docker Daemon". This listens to requests from the desktop app and executes them. If this isn't running nothing else will work.
    The "Docker Desktop" GUI. Starting the GUI should start the server, at least that's how I usually ensure the server is running. The GUI is the visual way to interact with Docker.
    The Docker CLI. As a developer, most of your work will be interacting with Docker via the CLI. I'd recommend using the GUI to visualize what's going on with Docker, but executing most of your commands through the command line.

Assignment

    Install Docker Desktop (don't worry, we'll mostly use the CLI):
        Install on macOS
        Install on Windows (or WSL 2)
        Install on Linux
    Run the Docker Desktop app. Make sure that in the bottom-left of the screen there is a green box with a whale icon in it. This indicates that the docker server is running locally and that you are connected to it. Then, make sure you're on Docker Desktop version 4+. At the time of writing, I'm on 4.40.0.
    Run docker version in your command line to make sure the CLI was installed.

Run and submit the CLI tests.

Tip

You may also want to enable shell completion for Docker.

# Install Docker
sudo pacman -S docker

# Enable and start the service
sudo systemctl enable docker
sudo systemctl start docker

# Add your user to the docker group (replace with your actual username)
sudo usermod -aG docker tomux

# Log out and back in (or reboot) to apply group change

# Verify access
docker info

# If permission denied persists:
groups                     # confirm docker group membership

#had to log in to docker in my terminal by running
echo "YOUR_TOKEN_OR_PASSWORD" | docker login --username YOUR_USERNAME --password-stdin 

#download the docker desktop gui
(see images/download_arch_docker_desktop_tar.png)

#install the docker desktop tar file
sudo pacman -U ~/Downloads/docker-desktop-x86_64.pkg.tar.zst

#if it fails its because u need to remove docker compose if installed
sudo pacman -R docker-compose

#initialize pass
gpg --generate-key

#once you get the generated keys
pass init <that long 23387843ASFDASF type of string>

#should see initialized message



          What Is Docker?


    Docker makes development efficient and predictable

    Docker takes away repetitive, mundane configuration tasks and is used throughout the development lifecycle for fast, easy and portable application development – desktop and cloud. Docker’s comprehensive end to end platform includes UIs, CLIs, APIs and security that are engineered to work together across the entire application delivery lifecycle.

    -- The Docker team

Put simply: Docker allows us to deploy our applications inside "containers", which are kind of like very lightweight virtual machines. Instead of just shipping an application, we can ship an application and the environment it runs in.

Docker is a way to define and run ____
both applications and enviornments


          Docker Hub

Docker Hub is the official cloud service for storing and sharing Docker images (we'll talk about images later, chill plz).

We'll use Docker Hub in this course, but there are other popular alternatives, and they're usually coupled with cloud service providers. For example,

    AWS ECR
    GCP Container Registry
    Azure Container Registry

For most of my career, if my company used AWS to deploy, we used AWS to host our images. If we used GCP to deploy, we hosted images on GCP. I'd usually just use whatever's most convenient and cost effective, the features are very similar between providers.

Assignment

    Create a free account on Docker Hub if you don't already have one.
    Open up your Docker Desktop app and click "Sign in". If it worked, you should see "Connected to Hub" at the bottom of the client. Having your local Docker environment connected to a Docker Hub account will make publishing your images much easier.



Run and submit the CLI tests.

The docker login command in the CLI tests should exit without error because you're already logged in.


        Containers


    A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.

    -- Docker

We've had virtual machines (like VirtualBox) for a long time. The trouble with virtual machines is that they're slow as h*ck. Booting one up usually takes longer than a physical machine.

Containers, on the other hand, gives us 90% of the benefits of virtual machines, but are super lightweight. Containers boot up in seconds, while virtual machines can take minutes.
Virtual Machine Architecture

Virtual Machine Architecture
(see images/vertual_machine_architectures.png)

Container (Docker) Architectures
(see images/container_architectures.png)

Why Are Containers Lightweight?

Virtual machines virtualize hardware, they emulate what a physical computer does at a low level. Containers virtualize at the operating system level. Isolation between containers that are running on the same machine is still really good. For the most part, each container feels like it has its own operating and filesystem. In reality, a lot of resources are being shared, but they're being shared securely through namespaces.

(see videos/vm_vs_container.mp4)

Which shares an underlying operating system?
docker containers

        
          Images


So a "container" is kinda like a lightweight VM, great... so what's an image?

    Image: A read-only definition of a container
    Container: an instance of a virtualized read-write environment

A container is basically an image that's actively running. In other words, you boot up a container from an image. You can create multiple separate containers all from the same image (it's kinda like the relationship between classes and objects).

(see videos/images_vs_containers.mp4)


Assignment

    Docker has a getting started image, go ahead and pull it down onto your local machine:

docker pull docker/getting-started

All this does is copy the image file down on your local machine so you won't have to download it later to be able to use it.

    Use the images command to view all the images you have saved. You should see the docker/getting-started listed:

docker images

    Open the Docker Desktop app. You should also see the image there under the "images" tab.

Run and submit the CLI tests.


          Run a Container


Now that you've downloaded the getting started image, let's run it inside a new container. The docker run command starts a new container from an image. Let's break down the syntax:

# this is just an example, don't run this
docker run -d -p hostport:containerport namespace/name:tag

    -d: Run in detached mode (doesn't block your terminal)
    -p: Publish a container's port to the host (forwarding)
    hostport: The port on your local machine
    containerport: The port inside the container
    namespace/name: The name of the image (usually in the format username/repo)
    tag: The version of the image (often latest)


Assignment

    Use the run command to start a new container from the "getting started" image:

docker run -d -p 8965:80 docker/getting-started:latest

    You should see the container running in the "Containers" tab of Docker Desktop. Run this on the command line to see the running containers:

docker ps

On one of the columns you should see this:

PORTS
0.0.0.0:8965->80/tcp

This is saying that port 8965 on your local "host" machine is being forwarded to port 80 on the running container. Port 80 is conventionally used for HTTP web traffic. Navigate to http://localhost:8965 and you should see a webpage served from the container!

Run and submit the CLI tests against your "getting started" container on http://localhost:8965.

Tip

If you want to use a different port, you can change the port the bootdev cli will use like this:

# if you want 42069
bootdev config base_url http://localhost:42069


          Stop a Container


Okay, now you know how to start a new instance of a container from an image... but how do you stop it? There are two primary ways:

    docker stop: This stops the container by issuing a SIGTERM signal to the container. You'll typically want to use docker stop.
    docker kill: This stops the container by issuing a SIGKILL signal to the container. This is a more forceful way to stop a container, and should be used as a last resort.

    # Stop all running containers
    docker stop $(docker ps -q)

    # Alternative using xargs
    docker ps -q | xargs docker stop
    
    #remove all stopped containers
    docker rm $(docker ps -aq)


Assignment

    Run docker ps again, and copy the container ID.
    Run docker stop CONTAINER_ID where CONTAINER_ID is the ID of your container
    Refresh the webpage (it shouldn't work anymore, the server is down!)

Run and submit the CLI tests.
Assignment

    Run docker ps again, and copy the container ID.
    Run docker stop CONTAINER_ID where CONTAINER_ID is the ID of your container
    Refresh the webpage (it shouldn't work anymore, the server is down!)

Run and submit the CLI tests.


                    Multiple Containers

Running a single container? That's easy. Realtm engineers control entire fleets of containers. Remember, Docker containers are very lightweight. It's normal to run many containers on a single host machine.

Remember, each container is its own isolated environment and process. Even if we start 10 containers from the same image, the image is just the definition of the container (the code and starting environment). Each container is a separate instance of that image.


Assignment

    Start five different instances of the docker/getting-started container, each time on a new port:

docker run -d -p 8965:80 docker/getting-started
docker run -d -p 8966:80 docker/getting-started
docker run -d -p 8967:80 docker/getting-started
docker run -d -p 8968:80 docker/getting-started
docker run -d -p 8969:80 docker/getting-started

We use port 80 within each container because that's the port that the application is binding to inside the container. It's being forwarded to the different ports we specify on the host (our) machine.

We have to use different host ports for different containers because two processes can't bind to the same port on the same operating system.

    Load each webpage in your browser to make sure it works:

    http://localhost:8965
    http://localhost:8966
    http://localhost:8967
    http://localhost:8968
    http://localhost:8969

Keep in mind, even though they all serve the same page, each is served from its own container!

    Run the ps command to see each running container:

docker ps

Run and submit the CLI tests.

When you're done running the tests, make sure to stop the containers.


          Volumes

By default, Docker containers don't retain any state from past containers. For example, if I:

    Start a container from an image
    Make some changes to the filesystem (like installing a new package) in that container
    Stop the container
    Start a new container from the same image
    The new container does not have the changes I made in step 2.

However, if I restart the stopped container, it will have the changes I made. This is only worth mentioning because sometimes developers think that killing an old container and starting a new one is the same as restarting a process - but that's not true... it's more like resetting the state of the entire machine to the original image.

All this said, Docker does have ways to support "persistent state" through storage volumes. They're basically a filesystem that lives outside of the container, but can be accessed by the container.

Assignment

Ghost is an open-source blogging software, kind of like WordPress. As you can imagine, blogging software that doesn't save your blog posts, would be pretty useless, so we'll install Ghost and use volumes to persist the state our data!

    Create a new empty volume called ghost-vol:

docker volume create ghost-vol

    Make sure it worked:

docker volume ls

    Inspect the volume to see where it is on your local machine:

docker volume inspect ghost-vol

Run and submit the CLI tests.


          Run Ghost

Cool, we've got a named volume ready to go. Time to run Ghost in Docker.
Assignment

Docker hosts an official image for Ghost on Docker Hub.

    Pull the Ghost image from Docker Hub:

docker pull ghost

    Run the Ghost image in a new container:

docker run -d -e NODE_ENV=development -e url=http://localhost:3001 -p 3001:2368 -v ghost-vol:/var/lib/ghost ghost

    -d runs the image in detached mode to avoid blocking the terminal.
    -e NODE_ENV=development sets an environment variable within the container. This tells Ghost to run in "development" mode (rather than "production", for instance)
    -e url=http://localhost:3001 sets another environment variable, this one tells Ghost that we want to be able to access Ghost via a URL on our host machine.
    We've used -p before. -p 3001:2368 does some port-forwarding between the container and our host machine.
    -v ghost-vol:/var/lib/ghost mounts the ghost-vol volume that we created before to the /var/lib/ghost path in the container. Ghost will use the /var/lib/ghost directory to persist stateful data (files) between runs.

    Navigate to http://localhost:3001/ in your browser, you should see your new Ghost CMS!

Run and submit the CLI tests against http://localhost:3001.


          Creating a Website

Let's create a new website using Ghost!
Assignment

    Navigate to Ghost's admin panel: http://localhost:3001/ghost/#/setup and create a new website:
        Title: "My Docker Blog"
        Name: your name
        Email: docker@test.com
        Password: correct horse
    Create a new post and publish it (pay attention to the letter casing and punctuation):
        Title: "I Love Docker"
        Content: "Truly I do."
    Go back to the homepage to see your post: http://localhost:3001/.

Run and submit the CLI tests against http://localhost:3001.
Assignment

    Navigate to Ghost's admin panel: http://localhost:3001/ghost/#/setup and create a new website:
        Title: "My Docker Blog"
        Name: your name
        Email: docker@test.com
        Password: correct horse
    Create a new post and publish it (pay attention to the letter casing and punctuation):
        Title: "I Love Docker"
        Content: "Truly I do."
    Go back to the homepage to see your post: http://localhost:3001/.

Run and submit the CLI tests against http://localhost:3001.


          Persist

Let's make sure our volume is working by starting a new container. If it's working, our new container will still serve the post we created because it will load it from the volume.

Assignment

    Get your container ID:

docker ps

    Stop and remove the container with the rm command:

docker stop CONTAINER_ID
docker rm CONTAINER_ID

    Start a new container from the same image and same volume:

docker run -d -e NODE_ENV=development -e url=http://localhost:3001 -p 3001:2368 -v ghost-vol:/var/lib/ghost ghost

Refresh your webpage and see if your site is still there. If it is, your volume is working as intended!

Run and submit the CLI tests.


          Persist Quiz

    A container's file system is read-write, but when you delete a container, and start a new one from the same image, that new container starts from scratch again with a copy of the image. All stateful changes are lost.
    A volume's file system is read-write, but it lives outside a single container. If a container uses a volume, then stateful changes can be persisted to the volume even if the container is deleted.

Volumes are often used by applications like Ghost, Grafana, or WordPress to persist data so that when a container is deleted and a new one is created the state of the application isn't lost. Containerized applications are typically thought of as ephemeral (temporary). If your application breaks just because you deleted and recreated a container... it's not a very good containerization!

If the post data is stored on the ____'s storage it will persist. If it's stored on the ____'s storage it will not persist.
volume, container
